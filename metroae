#!/usr/bin/env bash
set -e

METROAE_VERSION="4.6.0"
SCRIPT_VERSION="1.5.0"
MENU=()

#################################################################################
#                             CONTAINER COMMANDS                                #
#################################################################################

MENU+=(',container'                    'Manage the MetroAE container'                                                             'container'  ''                       '')
MENU+=(',container,pull'               'Pull a new MetroAE image from the registry'                                               'container'  'pull'                   ',container,pull')
MENU+=(',container,setup'              'Setup the MetroAE container'                                                              'container'  'setup'                  ',container,setup')
MENU+=(',container,start'              'Start the MetroAE container'                                                              'container'  'start'                  ',container,start')
MENU+=(',container,stop'               'Stop the MetroAE container'                                                               'container'  'stop'                   ',container,stop')
MENU+=(',container,status'             'Display the status of the MetroAE container'                                              'container'  'status'                 ',container,status')
MENU+=(',container,destroy'            'Destroy the MetroAE container'                                                            'container'  'destroy'                ',container,destroy')
MENU+=(',container,update'             'Update the MetroAE container to the latest version'                                       'container'  'upgrade-engine'         ',container,update')
MENU+=(',container,download'           'Download the container in tar format'                                                     'tools'      'download'               ',container,download')
MENU+=(',container,download,image'     'Download the container in tar format'                                                     'tools'      'download'               ',container,download')
MENU+=(',container,download,templates' 'Download the MetroAE Config templates and VSD specifications in tar format'               'tools'      'download-templates'     ',container,download,templates')
MENU+=(',container,load'               'Load container onto host from downloaded tar file'                                        'container'  'load'                   ',container,download')
MENU+=(',container,load,image'         'Load container onto host from downloaded tar file'                                        'container'  'load'                   ',container,download')
MENU+=(',container,load,templates'     'Load MetroAE Config templates and VSD specifications onto host from downloaded tar file'  'container'  'load-templates'         ',container,load,templates')

#################################################################################
#                                  VARIABLES                                    #
#################################################################################

# Switch
ANSIBLE_CONFIG_FILE="ansible.cfg"
CLI_ARGS=""

# Menu
MENU_STRIDE=5                                                          # Menu steps
MENU_KEY=""
SUB_MENU=""
MATCH_MENU=""
EXTRA_ARGS=()
PLAYBOOK_MENU="menu"

# Common
LINUX=0
NON_LINUX=1
FALSE=0
TRUE=1
CONTAINER_ID=''
RUNNING_CONTAINER_ID=''
IMAGE_ID=''
if [[ -z $MAX_CONTAINER_VERSION ]]; then
    MAX_CONTAINER_VERSION='current'
fi
DOCKER_REPO="nuagenetworks"
METRO_AE_IMAGE="$DOCKER_REPO/metroae"
if [[ ! -z $IMAGE_NAME ]]; then
    METRO_AE_IMAGE="$DOCKER_REPO/$IMAGE_NAME"
fi
OS_RELEASE=$LINUX
SETUP_USER_DATA_PATH=""
ENVIRONMENT_FILTERS=(PWD PATH HOME USER SHELL MAIL SSH_CONNECTION LOGNAME OLDPWD LESSOPEN _ XDG_RUNTIME_DIR HISTCONTROL)
CONTAINER_TAR_FILE=metroaecontainer.tar
if [[ ! -z $IMAGE_NAME ]]; then
    CONTAINER_TAR_FILE="$IMAGE_NAME.tar"
fi
DOCKER_REGISTRY_BASE='https://registry-1.docker.io'
DOCKER_AUTH_BASE='https://auth.docker.io'
DOCKER_AUTH_SERVICE='registry.docker.io'
DOCKER_DOWNLOAD_WORK_DIR="metroaecontainer-download"
CONTAINER_HOME=/source
UUID_FILE=.uuid
if [[ -z $UUID ]]; then
    UUID=""
fi
if [[ -z $SKIP_UUID ]]; then
    SKIP_UUID=$FALSE
fi
PHONE_HOME_URL="https://nuagemetroae-487c.restdb.io/rest/usage"
PHONE_HOME_API_KEY="ce4d6cfa136a9cf10b46d92fd613eb8c50f4d"
CONTAINER_MOUNT_POINT=/metroae_data
INSTALL_FOLDER=/opt/metroae
if [[ -z $SCRIPT_LOG_FILE ]]; then
    SCRIPT_LOG_FILE=/opt/metroae/metroae.log
fi

if [[ -z $SETUP_FILE ]]; then
    SETUP_FILE=/opt/metroae/.metroae
fi

TAB_COMPLETION_SCRIPT=tab-completion-metroae.sh
COMPLETION_DIR=/etc/bash_completion.d/
CURRENT_DIR=`pwd`
PLAYBOOK_DIR=$CURRENT_DIR/src/playbooks
PLAYBOOK_WITH_BUILD_DIR=$CURRENT_DIR/src/playbooks/with_build
ROLES_DIR=$CURRENT_DIR/src/roles
SCHEMA_DIR=$CURRENT_DIR/schemas
DEPLOYMENTS_BASE_DIR=$CURRENT_DIR/deployments
DEPLOYMENT_DIR=$DEPLOYMENTS_BASE_DIR/default
INVENTORY_DIR=$CURRENT_DIR/src/inventory
PLUGIN_DIR=$CURRENT_DIR/src/metro_plugins
VAULT_ENV_FILE=$CURRENT_DIR/src/vault-env
ENCRYPTED_TOKEN=\$ANSIBLE_VAULT
AUDIT_LOG=audit.log
ORIGINAL_ARGS=""
SKIP_BUILD=0
SKIP_PASSWORD=0
POSITIONAL=()
CONTAINER_RUN_MODE="CONTAINER"
REPO_RUN_MODE="REPO"
INSIDE_RUN_MODE="INSIDE"
CONFIG_SETUP_TYPE="c"
DEPLOY_SETUP_TYPE="d"
BOTH_SETUP_TYPE="b"
CONTAINER_STOPPED=0
CONTAINER_DELETED=0
TEMPLATE_TAR_LOCATION="https://metroae-config-templates.s3.amazonaws.com/metroae_config.tar"
VSD_SPECIFICATIONS_LOCATION="https://vsd-api-specifications.s3.us-east-2.amazonaws.com/specifications.tar"
TEMPLATE_DIR="standard-templates"
SPECIFICATION_DIR="vsd-api-specifications"

function read_setup_files {
    while read -r line; do declare -g $line; done < $SETUP_FILE
}

function print_write_permission_warning {
    debug ${FUNCNAME[0]}
    echo ""
    echo "WARNING: This user does not have Write permissions for MetroAE log file: $SCRIPT_LOG_FILE"
    echo "Ensure that the MetroAE install directory $INSTALL_FOLDER and its contents belongs to"
    echo "group 'docker' and that group write permissions are set. Continuing..."
    echo ""
}

function debug {
    if [[ ! -z $METROAE_DEBUG ]]; then
        write_to_screen_and_script_log "  DEBUG: $1"
    fi
}

function write_to_script_log {
    if [[ -f $SCRIPT_LOG_FILE ]]; then
        if [ -w "$SCRIPT_LOG_FILE" ]; then
            echo "$(date): $1" >> $SCRIPT_LOG_FILE
        else
            if [ -z $METROAE_WRITE_WARNING_PRINTED ]; then
                print_write_permission_warning
                METROAE_WRITE_WARNING_PRINTED=1
            fi
        fi
    fi
}

function write_to_screen_and_script_log {
    echo "$1"
    write_to_script_log "$1"
}

function check_run_mode {
    debug ${FUNCNAME[0]}
    if [[ -z $RUN_MODE ]]; then
        if [[ -f $ANSIBLE_CONFIG_FILE ]]; then
            RUN_MODE=$REPO_RUN_MODE
        else
            RUN_MODE=$CONTAINER_RUN_MODE
        fi
    fi
    debug "${FUNCNAME[0]}: RUN_MODE is $RUN_MODE"
}

function phone_home {
    if [[ $UUID == "" ]]; then
        debug "${FUNCNAME[0]}: Skipping Phone home"
    else
        # append and create json data
        json_data=""
        while [[ $# -gt 0 ]]; do
          json_data+="$1,"
          shift
        done
        json_data=`echo $json_data | sed 's/.$//'`
        debug "${FUNCNAME[0]}: curl -vvvv -k -H \"Content-Type: application/json\"\
          -H \"x-apikey: $PHONE_HOME_API_KEY\"\
          -X POST -d '{$json_data}'\
          $PHONE_HOME_URL"

        curl -vvvv -k -H "Content-Type: application/json"\
          -H "x-apikey: $PHONE_HOME_API_KEY"\
          -X POST -d "{$json_data}"\
          $PHONE_HOME_URL >> /dev/null 2>&1 &
    fi
}

function  check_if_internal_user {
    debug ${FUNCNAME[0]}

    if [[ $SKIP_UUID -eq $TRUE ]]; then
        debug "${FUNCNAME[0]}: Using existing UUID $UUID"
    else
        set +e
        int_user_check=`ping -c 5 github.mv.usa.alcatel.com 2>&1`
        SKIP_UUID=$?
        set -e
        debug "${FUNCNAME[0]} $int_user_check"

        if [[ $SKIP_UUID -eq $FALSE ]]; then
            echo ""
            write_to_screen_and_script_log "We have detected that this setup of MetroAE is internal to Nokia."
            write_to_screen_and_script_log "We would like to collect usage information to improve the tool,"
            write_to_screen_and_script_log "no personally identifiable information will be collected as part of this process."
            if [[ $RUN_MODE == $REPO ]]; then
                write_to_screen_and_script_log "Just remove file src/$UUID_FILE to opt out later"
            else
                write_to_screen_and_script_log "Just remove file $METROAE_MOUNT_POINT/$UUID_FILE to opt out later"
            fi
            echo ""

            declare -l continue_confirm
            continue_confirm="init"
            while [[ $continue_confirm != "y" ]] && [[ $continue_confirm != "n" ]] && [[ $continue_confirm != "" ]]
            do
                read -p " Would like to share usage data with MetroAE team? (y/N): " continue_confirm
            done

            if [[ $continue_confirm != "y" ]] ; then
                SKIP_UUID=$TRUE
            fi
        else
            SKIP_UUID=$TRUE
        fi
    fi
}

function generate_UUID {
    debug ${FUNCNAME[0]}
    UUID=`uuidgen`
    debug "${FUNCNAME[0]}: UUID=$UUID"
}

function generate_and_save_UUID {
    debug ${FUNCNAME[0]}
    if [[ $SKIP_UUID -eq $TRUE ]]; then
        debug "${FUNCNAME[0]}: Skipping UUID generation"
    else

        check_if_internal_user

        debug "${FUNCNAME[0]}: RUN_MODE = $RUN_MODE"
        if [[ $RUN_MODE == $INSIDE_RUN_MODE ]]; then
            debug "${FUNCNAME[0]}: Creating $CONTAINER_MOUNT_POINT/$UUID_FILE"
            touch $CONTAINER_MOUNT_POINT/$UUID_FILE
            sudo chown root:docker $CONTAINER_MOUNT_POINT/$UUID_FILE
            if [[ $SKIP_UUID -eq $FALSE ]]; then
                generate_UUID
                echo UUID=$UUID > $CONTAINER_MOUNT_POINT/$UUID_FILE
                SKIP_UUID=$TRUE
            fi
            debug "${FUNCNAME[0]}: SKIP_UUID = $SKIP_UUID"
            echo SKIP_UUID=$SKIP_UUID >> $CONTAINER_MOUNT_POINT/$UUID_FILE
        elif [[ $RUN_MODE == $REPO_RUN_MODE ]]; then
            debug "${FUNCNAME[0]}: Creating src/$UUID_FILE"
            touch src/$UUID_FILE
            if [[ $SKIP_UUID -eq $FALSE ]]; then
                generate_UUID
                echo UUID=$UUID > src/$UUID_FILE
                SKIP_UUID=$TRUE
            fi
            debug "${FUNCNAME[0]}: SKIP_UUID = $SKIP_UUID"
            echo SKIP_UUID=$SKIP_UUID >> src/$UUID_FILE
        else # RUN_MODE == $CONTAINER_RUN_MODE
            debug "${FUNCNAME[0]}: Creating $METROAE_MOUNT_POINT/$UUID_FILE"
            touch $METROAE_MOUNT_POINT/$UUID_FILE
            sudo chown root:docker $METROAE_MOUNT_POINT/$UUID_FILE
            if [[ $SKIP_UUID -eq $FALSE ]]; then
                generate_UUID
                echo UUID=$UUID > $METROAE_MOUNT_POINT/$UUID_FILE
                SKIP_UUID=$TRUE
            fi
            debug "${FUNCNAME[0]}: SKIP_UUID = $SKIP_UUID"
            echo SKIP_UUID=$SKIP_UUID >> $METROAE_MOUNT_POINT/$UUID_FILE
        fi
    fi
}

function source_UUID {
    debug ${FUNCNAME[0]}
    debug "${FUNCNAME[0]}: RUN_MODE = $RUN_MODE"
    if [[ $RUN_MODE == $INSIDE_RUN_MODE ]]; then
        if [[ -f $CONTAINER_MOUNT_POINT/$UUID_FILE ]]; then
            source $CONTAINER_MOUNT_POINT/$UUID_FILE
            debug "${FUNCNAME[0]}: source $CONTAINER_MOUNT_POINT/$UUID_FILE"
        fi
    elif [[ $RUN_MODE == $REPO_RUN_MODE ]]; then
        if [[ -f src/$UUID_FILE ]]; then
            source src/$UUID_FILE
            debug "${FUNCNAME[0]}: source src/$UUID_FILE"
        fi
    else # RUN_MODE == $CONTAINER_RUN_MODE
        if [[ -f $METROAE_MOUNT_POINT/$UUID_FILE ]]; then
            source $METROAE_MOUNT_POINT/$UUID_FILE
            debug "${FUNCNAME[0]}: source $METROAE_MOUNT_POINT/$UUID_FILE"
        fi
    fi
}

function source_menu {
    debug ${FUNCNAME[0]}
    debug "${FUNCNAME[0]}: RUN_MODE = $RUN_MODE"
    if [[ $RUN_MODE == $INSIDE_RUN_MODE ]]; then
        if [[ -f $CONTAINER_HOME/nuage-metroae/src/$PLAYBOOK_MENU ]]; then
            source $CONTAINER_HOME/nuage-metroae/src/$PLAYBOOK_MENU
            debug "${FUNCNAME[0]}: source $CONTAINER_HOME/nuage-metroae/src/$PLAYBOOK_MENU"
        fi
        if ls /source/nuage-metroae/src/metro_plugins/* 1> /dev/null 2>&1; then
            source_plugin_menus /source/nuage-metroae/src/metro_plugins
        fi
    elif [[ $RUN_MODE == $REPO_RUN_MODE ]]; then
        if [[ -f src/$PLAYBOOK_MENU ]]; then
            source src/$PLAYBOOK_MENU
            debug "${FUNCNAME[0]}: source src/$PLAYBOOK_MENU"
        fi
        if ls src/metro_plugins/* 1> /dev/null 2>&1; then
            source_plugin_menus src/metro_plugins
        fi
    else # RUN_MODE == $CONTAINER_RUN_MODE
        if [[ -f $METROAE_MOUNT_POINT/$PLAYBOOK_MENU ]]; then
            source $METROAE_MOUNT_POINT/$PLAYBOOK_MENU
            debug "${FUNCNAME[0]}: source $METROAE_MOUNT_POINT/$PLAYBOOK_MENU"
        fi
        if ls $METROAE_MOUNT_POINT/metro_plugins/* 1> /dev/null 2>&1; then
            source_plugin_menus $METROAE_MOUNT_POINT/metro_plugins
        fi
    fi
}

function source_plugin_menus {
    debug ${FUNCNAME[0]}
    plugin_dir=$1
    if [[ ! -d $plugin_dir ]]; then
        write_to_screen_and_script_log "Could not find plugin directory $plugin_dir"
        print_version_and_exit 1
    fi
    for plugin in $plugin_dir/*
        do
            menu_file=$plugin/menu
            if [[ -f $menu_file ]]; then
                source $menu_file
                debug "${FUNCNAME[0]}: source $menu_file"
            else
                write_to_screen_and_script_log "Could not find required menu file for plugin $plugin"
                print_version_and_exit 1
            fi
        done
}

function source_container_config {
    debug ${FUNCNAME[0]}
    if [[ -f $SETUP_FILE ]]; then
        source $SETUP_FILE
    else
        METROAE_SETUP_TYPE=$DEPLOY_SETUP_TYPE
        METROAE_MOUNT_POINT="./"
    fi
    debug "${FUNCNAME[0]}: METROAE_SETUP_TYPE = $METROAE_SETUP_TYPE"
    debug "${FUNCNAME[0]}: METROAE_MOUNT_POINT = $METROAE_MOUNT_POINT"
}

function check_for_prerequisite {
    debug ${FUNCNAME[0]}
    debug "${FUNCNAME[0]}: RUN_MODE = $RUN_MODE"
    if [[ $RUN_MODE == $INSIDE_RUN_MODE ]]; then
        if [[ ! -f $CONTAINER_HOME/nuage-metroae/src/$PLAYBOOK_MENU ]]; then
            write_to_screen_and_script_log "It looks like you are running MetroAE from inside the container, but we couldn't find the container's menu file in the data directory. Please run 'metroae container setup' and try again."
            exit 1
        fi
    elif [[ $RUN_MODE == $REPO_RUN_MODE ]]; then
        if [[ ! -f src/$PLAYBOOK_MENU ]]; then
            write_to_screen_and_script_log "It looks like you are trying to run using a clone of MetroAE, but we couldn't find the menu file in the workspace. Please update your workspace and try again."
            exit 1
        fi
    else # Must be CONTAINER_RUN_MODE
        check_for_user_group "$@"
        get_running_container_id
        if [[ -f $SETUP_FILE ]]; then
            debug "${FUNCNAME[0]}: Found $SETUP_FILE"
            if [[ -z $RUNNING_CONTAINER_ID ]]; then
                debug "${FUNCNAME[0]}: No container found"
                get_container_id
                if [[ -z $CONTAINER_ID ]]; then
                    echo ""
                    write_to_screen_and_script_log "It looks like there is a MetroAE container setup file, but we couldn't find the container."
                    write_to_screen_and_script_log "Please run 'metroae container setup' to fix this and try again."
                    echo ""
                    exit 1
                else
                    debug "${FUNCNAME[0]}: Container found"
                    echo ""
                    write_to_screen_and_script_log ">>> Starting the stopped container"
                    echo ""
                    docker start $CONTAINER_ID
                fi
            fi
            if [[ ! -f $METROAE_MOUNT_POINT/$PLAYBOOK_MENU ]]; then
                write_to_screen_and_script_log "It looks like you are trying to run the MetroAE container, but we couldn't find the container's menu file in the data directory."
                write_to_screen_and_script_log "Please run 'metroae container setup' to fix this and try again."
                exit 1
            fi
        else
            debug "${FUNCNAME[0]}: Not found $SETUP_FILE"
            if [[ ! -z $RUNNING_CONTAINER_ID ]]; then
                write_to_screen_and_script_log "It looks like the MetroAE container is running, but we couldn't find the container's setup file."
                write_to_screen_and_script_log "Please run 'metroae container setup' to fix this and try again."
                exit 1
            else
                echo ""
                write_to_screen_and_script_log "It looks like the MetroAE container has not been setup."
                write_to_screen_and_script_log "Please run 'metroae container setup' to fix this and try again."
                echo ""
                exit 1
            fi
        fi
    fi
}

function print_version_and_exit {
    debug ${FUNCNAME[0]}
    if [[ $1 == 0 ]]; then
        echo ""
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            get_max_container_version
            debug "${FUNCNAME[0]}: [MetroAE $METROAE_VERSION, script $SCRIPT_VERSION, container $MAX_CONTAINER_VERSION]"
        elif [[ $RUN_MODE == $REPO_RUN_MODE ]]; then
            if [[ ! ${MATCH_MENU[0]} =~ ",container*" ]] && [[ ! ${MATCH_MENU[0]} =~ ",config*" ]]; then
                debug "${FUNCNAME[0]}: [MetroAE $METROAE_VERSION, script $SCRIPT_VERSION]"
            fi
        fi
    fi
    exit $1
}

#################################################################################
#                                   COMMON                                      #
#################################################################################

function check_docker {
    debug ${FUNCNAME[0]}
    set +e

    debug "${FUNCNAME[0]}: Checking docker version"
    if [[ -f $SCRIPT_LOG_FILE ]]; then
        if [ -w "$SCRIPT_LOG_FILE" ]; then
            docker --version >> $SCRIPT_LOG_FILE 2>> $SCRIPT_LOG_FILE
        else
            if [ -z $METROAE_WRITE_WARNING_PRINTED ]; then
                print_write_permission_warning
                METROAE_WRITE_WARNING_PRINTED=1
            fi
        fi
    else
        docker --version >> /dev/null 2>> /dev/null
    fi

    if [[ $? -ne 0 ]]; then
        write_to_screen_and_script_log "Docker engine must be installed in order to run MetroAE. Quitting. Please install Docker and try again. See https://docs.docker.com for details"
        print_version_and_exit 1
    else
        DOCKER_VERSION=$(docker --version 2>> /dev/null)
        debug "${FUNCNAME[0]}: Docker version = $DOCKER_VERSION"
    fi
    set -e
}

function get_host_operating_system {
    debug ${FUNCNAME[0]}
    set +e
    stat /etc/os-release >> /dev/null 2>> /dev/null
    if [ $? -ne 0 ]
    then
        OS_RELEASE=$NON_LINUX
    fi
    debug "${FUNCNAME[0]}: OS_RELEASE: $OS_RELEASE"
    set -e
}

function get_max_container_version {
    debug ${FUNCNAME[0]}
    if [[ ! -z $IMAGE_TAG ]]; then
        MAX_CONTAINER_VERSION=$IMAGE_TAG
    else
        versions=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | awk '{ print $2}'`
        debug "${FUNCNAME[0]}: versions = $versions"
        MAX_CONTAINER_VERSION=''
        for version in $versions
        do
            if [[ $version != "<none>" ]]; then
                debug "${FUNCNAME[0]}: version = $version"
                if [[ -z $MAX_CONTAINER_VERSION ]]; then
                        MAX_CONTAINER_VERSION=$version
                fi

                if [[ $MAX_CONTAINER_VERSION < $version ]]; then
                        MAX_CONTAINER_VERSION=$version
                fi
            fi
            debug "${FUNCNAME[0]}: MAX_CONTAINER_VERSION = $MAX_CONTAINER_VERSION"
        done

        if [[ -z $MAX_CONTAINER_VERSION ]]; then
            MAX_CONTAINER_VERSION='current'
        fi
    fi
    debug "${FUNCNAME[0]}: Newest MetroAE container version found is $MAX_CONTAINER_VERSION"
}

function get_container_id {
    debug ${FUNCNAME[0]}
    CONTAINER_ID=`docker ps -a 2>/dev/null | grep $METRO_AE_IMAGE | awk '{ print $1}'`
    debug "${FUNCNAME[0]}: CONTAINER_ID: $CONTAINER_ID"
}

function get_running_container_id {
    debug ${FUNCNAME[0]}
    RUNNING_CONTAINER_ID=`docker ps 2>/dev/null | grep $METRO_AE_IMAGE | awk '{ print $1}'`
    debug "${FUNCNAME[0]}: RUNNING_CONTAINER_ID: $RUNNING_CONTAINER_ID"
}

function get_image_id {
    debug ${FUNCNAME[0]}
    if [[ -z $IMAGE_ID ]]; then
        get_max_container_version
        IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $MAX_CONTAINER_VERSION | awk '{ print $3}'`
    fi
    debug "${FUNCNAME[0]}: IMAGE_ID: $IMAGE_ID"
}


function stop_running_container {
    debug ${FUNCNAME[0]}
    echo ""
    write_to_screen_and_script_log ">>> Stopping the MetroAE container"
    echo ""
    get_running_container_id

    if [[ -z $RUNNING_CONTAINER_ID  ]]; then
        write_to_screen_and_script_log "The MetroAE container is not running. Nothing to do."
        return 0
    fi

    set +e
    docker stop $RUNNING_CONTAINER_ID
    status=$?
    if [[ $status -ne 0 ]]; then
        write_to_screen_and_script_log "Attempt to stop MetroAE container failed"
    else
        write_to_screen_and_script_log "The MetroAE container was stopped"
        CONTAINER_STOPPED=1
    fi
    set -e

    return $status
}

function delete_container_id {
    debug ${FUNCNAME[0]}
    echo ""
    write_to_screen_and_script_log ">>> Deleting the MetroAE container"
    echo ""
    get_container_id
    if [[ -z $CONTAINER_ID ]]; then
        write_to_screen_and_script_log "MetroAE container not found. Nothing to do."
        return 0
    fi

    debug "${FUNCNAME[0]}: Execute 'docker rm' on the MetroAE container with id $CONTAINER_ID"

    set +e
    if [[ -f $SCRIPT_LOG_FILE ]]; then
        if [ -w "$SCRIPT_LOG_FILE" ]; then
            docker rm -v $CONTAINER_ID | tee -a $SCRIPT_LOG_FILE
        else
            if [ -z $METROAE_WRITE_WARNING_PRINTED ]; then
                print_write_permission_warning
                METROAE_WRITE_WARNING_PRINTED=1
            fi
            docker rm -v $CONTAINER_ID
        fi
    else
        docker rm -v $CONTAINER_ID
    fi

    if [[ $? -ne 0 ]]; then
        write_to_screen_and_script_log "Attempt to execute 'docker rm' on the MetroAE container failed"
        return 1
    fi
    set -e

    write_to_screen_and_script_log "Execute of 'docker rm' on the MetroAE container was successful"
    CONTAINER_DELETED=1
}

function destroy {
    debug ${FUNCNAME[0]}
    declare -l confirmation
    if [[ -z $1 ]]; then
        confirmation="init"
        echo ""
        write_to_screen_and_script_log "It looks like you are about to destroy the MetroAE container."
        echo "If you continue, the MetroAE container will be stopped, the MetroAE container image will be"
        echo "removed from Docker, and your data on disk will be preserved. Your data will"
        echo "not be destroyed. You will be able to use it again by pulling another MetroAE"
        echo "container and running 'metroae container setup'."
        while [[ $confirmation != "n" ]] && [[ $confirmation  != "y" ]] && [[ $confirmation != "" ]]
        do
            echo ""
            read -p "Do you really want to destroy the MetroAE container? (y/N): " confirmation
        done
    else
        confirmation=$1
    fi

    if [[ $confirmation != "y" ]]; then
        echo ""
        write_to_screen_and_script_log "Destroy of metroae container was canceled"
        echo ""
        print_version_and_exit 0
    fi

    set +e
    container_image=`docker ps 2>/dev/null | grep $METRO_AE_IMAGE | awk '{ print $2 }'`
    IMAGE_TAG=${container_image##*:}
    stop_running_container
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    delete_container_id
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    set -e

    echo ""
    write_to_screen_and_script_log ">>> Removing MetroAE image"
    echo ""

    get_image_id
    if [[ -z $IMAGE_ID ]]; then
        write_to_screen_and_script_log "MetroAE container image not found. Nothing to do."
        return 0
    fi

    set +e
    if [[ "$CONTAINER_STOPPED" -eq "1" ]] && [[ "$CONTAINER_DELETED" -eq "1" ]]; then

        docker rmi -f $IMAGE_ID

        if [[ $? -ne 0 ]]; then
          echo ""
          write_to_screen_and_script_log "Attempt to remove the MetroAE image failed"
          echo ""
          return 1
        fi

        set -e
        echo ""
        write_to_screen_and_script_log "The MetroAE container image was removed"
        echo ""

        return 0

    fi

    echo ""
    write_to_screen_and_script_log "No container stopped and removed. No MetroAE container image needs to be removed"
    echo ""

}

function pull {
    debug ${FUNCNAME[0]}
    if [[ ! -z $1 ]]; then
        MAX_CONTAINER_VERSION=$1
    fi
    debug "${FUNCNAME[0]}: MAX_CONTAINER_VERSION: $MAX_CONTAINER_VERSION"

    set -e

    echo ""
    write_to_screen_and_script_log ">>> Pulling the MetroAE container image from Docker hub"
    echo ""
    if [[ -f $SCRIPT_LOG_FILE ]]; then
        if [ -w "$SCRIPT_LOG_FILE" ]; then
            debug "${FUNCNAME[0]}: Script log is writable"
            sudo docker pull $METRO_AE_IMAGE:$MAX_CONTAINER_VERSION | tee -a $SCRIPT_LOG_FILE
        else
            if [ -z $METROAE_WRITE_WARNING_PRINTED ]; then
                print_write_permission_warning
                METROAE_WRITE_WARNING_PRINTED=1
            fi
            debug "${FUNCNAME[0]}: Script log is not writable"
            sudo docker pull $METRO_AE_IMAGE:$MAX_CONTAINER_VERSION
        fi
    else
        debug "${FUNCNAME[0]}: Script log is not found"
        sudo docker pull $METRO_AE_IMAGE:$MAX_CONTAINER_VERSION
    fi

    status=$?
    if [[ $status -ne 0 ]]; then
        write_to_screen_and_script_log "Attempt to pull the $MAX_CONTAINER_VERSION MetroAE container image failed. Quitting."
        exit 1
    else
        write_to_screen_and_script_log "Successfully pulled the MetroAE container image from Docker hub"
    fi
    set -e

    return $status
}

function run_container {
    debug ${FUNCNAME[0]}

    get_image_id

    if [[ -z $IMAGE_ID ]];  then
        set +e
        write_to_screen_and_script_log "We didn't find the MetroAE container image. We are pulling a new container from the repo."
        pull
        status=$?
        set -e
        if [ $status -ne 0 ]
        then
            write_to_screen_and_script_log "Attempt to pull the MetroAE container failed. Quitting."
            return $status
        fi
    else
        get_container_id

        set +e
        echo ""
        write_to_screen_and_script_log ">>> Starting the MetroAE container"
        echo ""
        if [[ -z $CONTAINER_ID ]]; then
            network_args=""
            get_host_operating_system
            if [[ $OS_RELEASE  -eq $LINUX ]]; then
                network_args="--network host"
            else
                network_args="-p $UI_PORT:5001"
            fi

            mount_args="-v $METROAE_MOUNT_POINT:/metroae_data:Z"

            if [[ ! -z $IMAGES_MOUNT_POINT ]]; then
                mount_args="$mount_args -v $IMAGES_MOUNT_POINT:/images:Z"
            fi

            if [[ $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
                levi_args="-e LEVISTATE_CONTAINER=1"
            else
                levi_args=""
            fi

            user_name=`id -u $(whoami)`
            group_name=`id -g $(whoami)`

            if [[ ! -z $IMAGE_TAG ]]; then
                MAX_CONTAINER_VERSION=$IMAGE_TAG
            fi

            DOCKER_COMMAND=$(cat <<-END
                docker run \
                    -e RUN_MODE=$INSIDE_RUN_MODE \
                    -e USER_NAME=$user_name \
                    -e GROUP_NAME=$group_name \
                    $levi_args \
                    -t -d \
                    $network_args \
                    $mount_args \
                    --name metroae $METRO_AE_IMAGE:$MAX_CONTAINER_VERSION
		END
            )
            debug "${FUNCNAME[0]}: DOCKER_COMMAND: $DOCKER_COMMAND"
            eval $DOCKER_COMMAND
        else
            debug "${FUNCNAME[0]}: docker start $CONTAINER_ID"
            docker start $CONTAINER_ID
        fi

        status=$?
        if [[ $status -ne 0 ]]; then
            echo ""
            write_to_screen_and_script_log "Attempt to run the MetroAE container failed. Quitting."
            print_version_and_exit 1
        else
            echo ""
            write_to_screen_and_script_log "MetroAE container started successfully"
        fi
        set -e
        return $status
    fi

    return 0
}

function setup_container {
    debug ${FUNCNAME[0]}
    local is_ui_run=false
    get_host_operating_system

    if [[ ! -d $INSTALL_FOLDER ]]; then
        sudo mkdir -p $INSTALL_FOLDER
    fi
    sudo chown -R root:docker $INSTALL_FOLDER
    sudo chmod -R 775 $INSTALL_FOLDER
    if [[ ! -f $SETUP_FILE ]]; then
        sudo touch $SETUP_FILE
        if [[ $OS_RELEASE -eq $NON_LINUX ]]; then
            debug "${FUNCNAME[0]}: sudo chmod 777 $SETUP_FILE"
            sudo chmod 777 $SETUP_FILE
        else
            debug "${FUNCNAME[0]}: sudo chmod 0774 $SETUP_FILE"
            sudo chmod 0774 $SETUP_FILE
        fi
    fi
    sudo chown root:docker $SETUP_FILE
    if [[ ! -f $SCRIPT_LOG_FILE ]]; then
        sudo touch $SCRIPT_LOG_FILE
        if [[ $OS_RELEASE -eq $NON_LINUX ]]; then
            sudo chmod 777 $SCRIPT_LOG_FILE
        else
            sudo chmod 0774 $SCRIPT_LOG_FILE
        fi
    fi
    sudo chown root:docker $SCRIPT_LOG_FILE

    get_container_id
    get_running_container_id

    if [[ ! -z $CONTAINER_ID ]] || [[ ! -z $RUNNING_CONTAINER_ID ]]; then
        echo ""
        write_to_screen_and_script_log "It looks like the MetroAE container is already setup."
        echo "If you want to update to the latest MetroAE container version, please quit setup"
        echo "and then run 'metroae container update' to get the latest container while keeping"
        echo "your current setup and data. Your data on disk will be preserved."
        echo ""
        echo "If you want to run setup, the existing MetroAE container will not be replaced."
        echo "We will stop the MetroAE container, reconfigure it according to your inputs,"
        echo "and restart the existing MetroAE container with the new configuration."
        echo ""
        echo "Note that if you want to re-use your existing deployments on disk after"
        echo "running setup, you must either specify the same directories when prompted"
        echo "for input or you must manually copy the files from the existing data locations"
        echo "on disk to the new locations."
        echo ""

        declare -l continue_confirm
        if [[ -z $1 ]]; then
            continue_confirm="init"
            while [[ $continue_confirm != "y" ]] && [[ $continue_confirm != "n" ]] && [[ $continue_confirm != "" ]]
            do
                read -p "Do you want to continue with setup? (y/N): " continue_confirm
            done
        else
            continue_confirm=$1
            shift
        fi

        if [[ $continue_confirm != "y" ]] ; then
            echo ""
            write_to_screen_and_script_log ">>> Setup canceled"
            echo ""
            return 0
        fi
    fi

    write_to_screen_and_script_log ">>> Setup MetroAE container"

    set +e

    images_on_disk=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | awk '{ print $2 }'`
    num_images=0
    for image in $images_on_disk
    do
        if [[ $image != "<none>" ]]; then
            num_images=$((num_images+1))
        fi
    done
    if [[ $num_images -gt 1 ]]; then
        if [[ -z $3 ]]; then
            echo "You can set up a container with one of the images currently"
            echo "pulled on the host machine"
            echo ""
            echo $images_on_disk
            read -p "Which image would you like to use for container setup? Please specify the image tag: " IMAGE_TAG_SELECTION
            if [[ ! -z $IMAGE_TAG_SELECTION ]]; then
                IMAGE_TAG=$IMAGE_TAG_SELECTION
            fi
            IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
        else
            for image in $images_on_disk
            do
                if [[ $image == $3 ]]; then
                    IMAGE_TAG=$image
                fi
            done
            if [[ -z $IMAGE_TAG ]]; then
                echo ""
                write_to_screen_and_script_log "The image you would like to set up does not exist on the host machine."
                echo "Pulling the requested image..."
                pull $3
                if [[ $? -ne 0 ]]; then
                    set -e
                    return 1
                fi
                IMAGE_TAG=$3
                IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
            else
                IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
            fi
        fi
    elif [[ $num_images -eq 1 ]]; then
        if [[ -z $3 ]]; then
            for image in $images_on_disk
            do
                if [[ $image != "<none>" ]]; then
                    IMAGE_TAG=$image
                fi
            done
            IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
        else
            if [[ $3 == $images_on_disk ]]; then
                IMAGE_TAG=$3
                IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
            else
                echo ""
                write_to_screen_and_script_log "The image you have specified does not match the image on the host machine."
                echo "Pulling the requested image..."
                pull $3
                if [[ $? -ne 0 ]]; then
                    set -e
                    return 1
                fi
                IMAGE_TAG=$3
                IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
            fi
        fi
    else
        if [[ ! -z $3 ]]; then
            echo ""
            write_to_screen_and_script_log "There are no images on the host machine, but an image has been specified for setup."
            echo "Pulling the requested image..."
            echo ""
            pull $3
            if [[ $? -ne 0 ]]; then
                set -e
                return 1
            fi
            IMAGE_TAG=$3
            IMAGE_ID=`docker images 2>/dev/null | grep $METRO_AE_IMAGE | grep $IMAGE_TAG | awk '{ print $3 }'`
        else
            get_image_id
            if [[ -z $IMAGE_ID ]]; then
                echo ""
                write_to_screen_and_script_log ">>> Pulling the MetroAE container image from the repository"
                pull
            fi

            if [[ $? -ne 0 ]]; then
                set -e
                return 1
            fi
        fi
    fi
    set -e

    if [[ -z $1 ]]; then
        echo ""
        write_to_screen_and_script_log "Data directory configuration"
        echo ""
        echo "The MetroAE container needs access to your user data. It gets access by internally"
        echo "mounting a directory from the host. We refer to this as the 'data directory'."
        echo "The data directory is where you will have deployments, templates, documentation,"
        echo "and other useful files."
        echo ""
        echo "Please specify the full path to the data directory on the Docker host. Setup will"
        echo "make sure that the path ends with 'metroae_data'. If the path you specify does"
        echo "not end with 'metroae_data', setup will create it."
        get_valid_data_dir

        create_data_directory $SETUP_USER_DATA_PATH

        echo ""
        write_to_screen_and_script_log "Data directory path set to: $SETUP_USER_DATA_PATH"
        echo ""
    else
        echo ""
        valid_path=1
        validate_directory $1
        if [[ $valid_path -ne 0 ]]; then
            exit 1
        fi
        SETUP_USER_DATA_PATH=$1
        shift
        write_to_screen_and_script_log ">>> Setting data directory path to passed in parameter $SETUP_USER_DATA_PATH"
    fi

    METROAE_MOUNT_POINT=$SETUP_USER_DATA_PATH
    if [ -w "$SETUP_FILE" ]; then
        sed -i '/^METROAE_MOUNT_POINT/d' $SETUP_FILE
        echo METROAE_MOUNT_POINT=$METROAE_MOUNT_POINT >> $SETUP_FILE
        debug "${FUNCNAME[0]}: METROAE_MOUNT_POINT=$METROAE_MOUNT_POINT"
    else
        echo ""
        write_to_screen_and_script_log "We couldn't write data directory name to the MetroAE setup file ($SETUP_FILE)."
        echo "Please ensure that the file has user:group ownership set to 'root:docker' and try again."
        echo "You can also delete the file and re-run 'metroae container setup'. Quitting."
        exit 1
    fi

    declare -l setup_type
    setup_type="init"
    if [[ -z $1 ]]; then
        while [[ $setup_type != $CONFIG_SETUP_TYPE ]] && [[ $setup_type != $DEPLOY_SETUP_TYPE ]] && [[ $setup_type != $BOTH_SETUP_TYPE ]] && [[ $setup_type != "" ]]
        do
            echo ""
            write_to_screen_and_script_log "Setup can configure the container to support MetroAE (c)onfig, MetroAE (d)eploy,"
            echo "or (b)oth MetroAE config and deploy. MetroAE config is used for day-zero VSD"
            echo "configuration tasks. MetroAE deploy is used for installing, upgrading, and"
            echo "health checking of Nuage VSP components in your environment."
            echo ""
            read -p "Do you want to setup MetroAE config, deploy, or both? (c/d/B): " setup_type
        done
    else
        echo ""
        setup_type=$1
        shift
        write_to_screen_and_script_log ">>> Setting setup type to passed in parameter $setup_type"
    fi

    if [[ $setup_type == $CONFIG_SETUP_TYPE ]]; then
        echo ""
        write_to_screen_and_script_log ">>> Setup container for MetroAE config"
    elif [[ $setup_type == $DEPLOY_SETUP_TYPE ]]; then
        echo ""
        write_to_screen_and_script_log ">>> Setup container for MetroAE deploy"
    else
        echo ""
        write_to_screen_and_script_log ">>> Setup container for both MetroAE config and deploy"
        setup_type=$BOTH_SETUP_TYPE
    fi

    if [ -w "$SETUP_FILE" ]; then
        sed -i '/^METROAE_SETUP_TYPE/d' $SETUP_FILE
        echo "METROAE_SETUP_TYPE=$setup_type" >> $SETUP_FILE
        debug "${FUNCNAME[0]}: METROAE_SETUP_TYPE=$setup_type"
    else
        echo ""
        write_to_screen_and_script_log "We couldn't write setup type to the MetroAE setup file ($SETUP_FILE). Please ensure"
        echo "that the file has user:group ownership set to 'root:docker' and try again."
        echo "You can also delete the file and re-run 'metroae container setup'. Quitting."
        exit 1
    fi

    # stop and remove existing container if any
    get_running_container_id
    if [[ ! -z $RUNNING_CONTAINER_ID ]]; then
        stop_running_container
    fi

    get_container_id
    if [[ ! -z $CONTAINER_ID ]]; then
        delete_container_id
    fi

    echo ""
    write_to_screen_and_script_log ">>> Prepare data directory for updates from new container."
    echo ""
    rm -rf $METROAE_MOUNT_POINT/version >> /dev/null 2>> /dev/null

    run_container
    update_container_files

    if [[ -z $NOT_INTERACTIVE ]]; then
      update_metroae
    fi

    setup_tab_completion

    set -e

    generate_and_save_UUID

    if [[ $config_template_status -ne 0 || $config_docs_status -ne 0 || $deploy_keys_status -ne 0 || $deploy_status -ne 0 || $common_status -ne 0 ]]; then
        echo ""
        write_to_screen_and_script_log "Setup of the MetroAE container is complete. However, we had a problem copying one or more files to the data directory."
        echo "The MetroAE container is running. You can use it, but you may not have the latest files on disk."
        echo "You can try running 'metroae container setup' again to correct this problem."
        echo ""
        exit 1
    else
        echo ""
        write_to_screen_and_script_log "Setup of the MetroAE container is complete. Execute 'metroae container status' for status."
        echo ""
        return 0
    fi
}

function update_container_files {
    debug ${FUNCNAME[0]}

    set +e
    common_status=0
    echo ""
    write_to_screen_and_script_log ">>> Updating common files and documentation for MetroAE in the container"
    echo ""
    docker_exec_copy_common_defaults
    common_status=$?

    deploy_status=0
    if [[ $setup_type != "c" ]]; then
        echo ""
        write_to_screen_and_script_log ">>> Updating with the latest documentation and examples for MetroAE deploy in the container"
        echo ""
        docker_exec_copy_deploy_defaults
        deploy_status=$?
    fi

    deploy_keys_status=0
    echo ""
    write_to_screen_and_script_log ">>> Generating and copying ssh keys for the container"
    echo ""
    docker_exec_generate_and_copy_keys
    deploy_keys_status=$?

    config_template_status=0
    if [[ $setup_type != "d" ]]; then
        echo ""
        write_to_screen_and_script_log ">>> Updating with the latest feature templates and files for MetroAE Config in the container"
        echo ""
        docker_exec_config templates update
        config_template_status=$?

        if [[ $config_template_status -eq 9 ]]; then
            echo ""
            read -p "Would you like to continue with MetroAE container setup? (y/n) " CONTINUE_SETUP
            if [[ $CONTINUE_SETUP == "n" ]]; then
                echo ""
                write_to_screen_and_script_log "Quitting MetroAE container setup..."
                echo "You can run 'metroae container setup' at any time to complete the setup process"
                exit 1
            else
                echo ""
                write_to_screen_and_script_log "Continuing with MetroAE container setup..."
                config_template_status=0
            fi
        fi

    fi

    config_docs_status=0
    if [[ $setup_type != "d" ]]; then
        echo ""
        write_to_screen_and_script_log ">>> Updating with the documentation for MetroAE Config in the container"
        echo ""
        docker_exec_copy_config_defaults
        config_docs_status=$?
    fi
}

function validate_directory {
    debug ${FUNCNAME[0]}

    set +e
    if [[ -w $SCRIPT_LOG_FILE ]]; then
        stat $1 >> $SCRIPT_LOG_FILE 2>> $SCRIPT_LOG_FILE
    else
        stat $1
    fi

    valid_path=$?
    if [[ $valid_path -ne 0 ]]; then
        write_to_screen_and_script_log "We had a problem validating the path you entered: $1. Please try again."
    fi
}

function create_data_directory {
    debug ${FUNCNAME[0]}

    if [[ $1 != *metroae_data ]]; then
        SETUP_USER_DATA_PATH=${SETUP_USER_DATA_PATH%/}/metroae_data
    fi
    mkdir -p $SETUP_USER_DATA_PATH
}

function get_valid_data_dir {
    debug ${FUNCNAME[0]}
    valid_path=1
    set +e

    while [[ $valid_path -ne 0 ]]
    do
        echo ""
        read -p "Data directory path: " SETUP_USER_DATA_PATH
        echo ""
        write_to_screen_and_script_log "Checking path: $1"
        validate_directory $SETUP_USER_DATA_PATH
    done
    set -e
}

function update_container {
    debug ${FUNCNAME[0]}
    declare -l confirmation
    if [[ -z $2 ]]; then
        confirmation="init"
        echo ""
        write_to_screen_and_script_log "You are about to update your MetroAE container to the latest version."
        echo "We will destroy the existing container, pull the latest version of the container,"
        echo "and start the container using the existing configuration."
        echo "Your data on disk will be preserved."
        while [[ $confirmation != "n" ]] && [[ $confirmation  != "y" ]] && [[ $confirmation != "" ]]
        do
            echo ""
            read -p "Do you really want to update the MetroAE container? (y/N): " confirmation
        done
    else
        confirmation=$2
    fi

    if [[ $confirmation != "y" ]]; then
        echo ""
        write_to_screen_and_script_log "Update of metroae container was canceled"
        echo ""
        print_version_and_exit 0
    fi

    set +e
    destroy y
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    set -e
    if [[ ! -z $1 ]]; then
        pull $1
    else
        pull
    fi
    run_container
    update_container_files

    if [[ -z $NOT_INTERACTIVE ]]; then
      update_metroae
    fi

    read_setup_files
    if [ -d $METROAE_MOUNT_POINT/metro_plugins/ ]; then
        for plugin_name in `ls $METROAE_MOUNT_POINT/metro_plugins/`; do
            if [ -d "$METROAE_MOUNT_POINT/metro_plugins/${plugin_name}" ]; then
                docker_metro_ae_exec plugin install "/metroae_data/metro_plugins/${plugin_name}"
            fi
        done
    fi
}

function check_if_mount_point_configured {
    debug ${FUNCNAME[0]}
    if [[ -z "$METROAE_MOUNT_POINT" ]]; then
        echo ""
        write_to_screen_and_script_log "We couldn't find the data directory configuration for the container in the configuration file."
        echo "Please run 'metroae container setup' to correct this and try again."
        echo ""
        return 1
    fi
}

function update_metroae {
    debug ${FUNCNAME[0]}
    declare -l confirmation
    if [[ $RUN_MODE == "CONTAINER" ]]; then
        if [[ -z $2 ]]; then
            confirmation="init"
            while [[ $confirmation != "n" ]] && [[ $confirmation  != "y" ]] && [[ $confirmation != "" ]]
            do
              echo ""
              echo "We recommend that you update your metroae script to the same version as the container you are loading."
              read -p "Would you like us to update the metroae script for you? (Y/n): " confirmation
            done
        else
            confirmation=$2
        fi

        if [[ $confirmation == "n" ]]; then
            echo ""
            write_to_screen_and_script_log "Update of metroae Script was canceled"
            echo ""
            return 0
        fi
        echo ""
        write_to_screen_and_script_log ">>> Updating your metroae script"
        echo ""

        if [[ -f $SETUP_FILE ]]; then
            while read -r line; do declare $line; done < $SETUP_FILE
        fi

        check_if_mount_point_configured

        echo ""
        write_to_screen_and_script_log ">>> Wait for the container to copy a new metroae file to the data directory"
        echo ""
        set +e
        timeout 10 bash -c -- "while [[ ! -f $METROAE_MOUNT_POINT/metroae ]]; do sleep 1; done"
        TEMP_RC=$?
        debug $TEMP_RC
        if [[ $TEMP_RC -ne 0 ]]; then
            write_to_screen_and_script_log "We didn't find $METROAE_MOUNT_POINT/metroae."
            echo "It could be that the version of metroae script you are running is the latest."
            echo "Your copy of the metroae script will not be updated. You can continue to use your copy."
            echo ""
            set -e
            return 0
        fi
        set +e
        cp $METROAE_MOUNT_POINT/metroae "${BASH_SOURCE[0]}"

        if [[ $? -ne 0 ]]; then
            write_to_screen_and_script_log "We encountered an error copying $METROAE_MOUNT_POINT/metroae."
            echo "Your copy of the metroae script will not be updated. You can continue to use your copy,"
            echo " but we suggest that you update your metroae script from the Github repo before continuing."
            echo ""
            set -e
            return 0
        fi
        set -e
        write_to_screen_and_script_log "Successfully updated your metroae script."
        echo ""
      fi
}

function setup_tab_completion {
    debug ${FUNCNAME[0]}
    set +e
    echo ""
    write_to_screen_and_script_log ">>> Setting up optional tab completion for your metroae script."
    echo ""

    check_if_mount_point_configured

    if [[ ! -d $COMPLETION_DIR ]]; then
        debug "${FUNCNAME[0]}: Creating tab-completion dir: $COMPLETION_DIR"
        set +e
        mkdir $COMPLETION_DIR
        if [[ $? -ne 0 ]]; then
            write_to_screen_and_script_log "We encountered an error creating the tab-completion directory on your host."
            echo "We will not be configuring optional metroae script tab completion."
            echo "You may continue to use the metroae script without tab completion."
            echo ""
        else
            debug "${FUNCNAME[0]}: Copying tab-completion to standard dir: $METROAE_MOUNT_POINT/$TAB_COMPLETION_SCRIPT to $COMPLETION_DIR"
            sudo cp $METROAE_MOUNT_POINT/$TAB_COMPLETION_SCRIPT $COMPLETION_DIR
            if [[ $? -ne 0 ]]; then
                write_to_screen_and_script_log "We encountered an error copying files to the tab-completion directory on your host."
                echo "We will not be configuring optional metroae script tab completion."
                echo "You may continue to use the metroae script without tab completion."
                echo ""
            else
                write_to_screen_and_script_log "Successfully configured optional metroae script tab completion."
                echo ""
            fi
        fi
    fi

    set -e
}

function run_container_if_not_running {
    debug ${FUNCNAME[0]}
    get_running_container_id

    if [[ -z $RUNNING_CONTAINER_ID ]]; then
        run_container
        get_running_container_id
    fi
}

function docker_exec {
    debug ${FUNCNAME[0]}
    run_container_if_not_running
    environment=""
    working_dir=""

    if [[ $1 == "env" ]]; then
        shift
        environment='-e ANSIBLE_FORCE_COLOR=true -e UUID=$UUID'
        for env in `env`
        do
            filtered=0
            for filter in ${ENVIRONMENT_FILTERS[@]}
            do
                if [[ "$env" =~ ^$filter ]]
                then
                    filtered=1
                fi
            done

        if [[ $filtered -eq 0 ]]; then
            environment="$environment -e $env"
        fi
        done

        if [[ ! -z $USER_DATA_PATH ]]; then
            environment="$environment -e USER_DATA_PATH=$USER_DATA_PATH"
        fi
    fi

    if [[ $1 == "workdir" ]]; then
        working_dir="-w $2"
        shift
        shift
    fi
    debug "${FUNCNAME[0]}: Env = $environment"
    debug "${FUNCNAME[0]}: Pwd = $working_dir"
    debug "${FUNCNAME[0]}: Container = $RUNNING_CONTAINER_ID"
    if [[ ! -z $METROAE_DEBUG ]]; then
        echo "$@"
    fi
    docker exec $environment $working_dir $RUNNING_CONTAINER_ID "$@"
}

function docker_exec_interactive {
    debug ${FUNCNAME[0]}
    environment=""
    if [[ ! -z $METROAE_PASSWORD ]]; then
        environment=" -e METROAE_PASSWORD=$METROAE_PASSWORD"
    fi
    if [[ ! -z $SSHPASS_PASSWORD ]]; then
        sshpass="sshpass -p$SSHPASS_PASSWORD"
    fi

    echo ""
    write_to_screen_and_script_log ">>> Starting interactive session with the container"
    echo ""

    if [[ ! -z $NOT_INTERACTIVE ]]; then
        environment="$environment -e NON_INTERACTIVE=true"
        docker exec $environment $RUNNING_CONTAINER_ID $sshpass "$@"
    else
        docker exec -it $environment $RUNNING_CONTAINER_ID $sshpass "$@"
    fi

    echo ""
    write_to_screen_and_script_log ">>> Exiting interactive session with the container"
    echo ""
}

function interactive {
    debug ${FUNCNAME[0]}
    run_container_if_not_running
    docker_exec_interactive /bin/bash
}

function check_for_user_group {
    debug ${FUNCNAME[0]}
    uid=`id -u`
    debug "${FUNCNAME[0]}: uid=$uid"
    get_host_operating_system
    if [[ $uid -eq 0 ]] || [[ $OS_RELEASE -eq $NON_LINUX ]]; then
        return 0
    fi

    set +e
    docker_group=`getent group docker`
    debug "${FUNCNAME[0]}: docker_group=$docker_group"
    set -e
    if [[ -z $docker_group ]]; then
        echo ""
        write_to_screen_and_script_log ">>> Adding docker group"
        sudo groupadd docker
        echo ""
        write_to_screen_and_script_log ">>> Restarting Docker"
        sudo systemctl restart docker
        if [[ -d $INSTALL_FOLDER ]]; then
            sudo chown -R root:docker $INSTALL_FOLDER
            sudo chmod -R 775 $INSTALL_FOLDER
        fi
    fi

    uid=`id -u`
    debug "${FUNCNAME[0]}: uid=$uid"
    get_host_operating_system

    set +e
    current_user=`whoami`
    debug "${FUNCNAME[0]}: current_user=$current_user"
    docker_part_of_groups=`id -nG $current_user | grep docker`
    debug "${FUNCNAME[0]}: docker_part_of_groups=$docker_part_of_groups"
    set -e
    if [[ -z "$docker_part_of_groups" ]]; then
        echo ""
        write_to_screen_and_script_log "It looks like the user `whoami` isn't a member of the 'docker' group. `whoami` must"
        write_to_screen_and_script_log "be a member of the 'docker' group to proceed."
        declare -l confirmation
        if [[ -z $1 ]]; then
            confirmation="init"
            while [[ $confirmation != "n" ]] && [[ $confirmation  != "y" ]] && [[ $confirmation != "" ]]
            do
                echo ""
                read -p "Do you want the current user to be added to the docker group: (y/N) " confirmation
            done
        else
            confirmation=$1
        fi

        if [[ $confirmation != "y" ]]; then
            echo ""
            write_to_screen_and_script_log "Please add the current user to the docker group and retry. Quitting"
            print_version_and_exit 1
        fi

        echo ""
        write_to_screen_and_script_log ">>> Adding `whoami` to the docker group"
        sudo gpasswd -a `whoami` docker >> /dev/null
        if [[ -z $NOT_INTERACTIVE ]]; then
            echo ""
            write_to_screen_and_script_log "We added user `whoami` to the docker group. For this one-time change to take effect,"
            write_to_screen_and_script_log "you must logout and back in before trying again."
            exit 0
        fi
    fi

}

function container_load {
    debug ${FUNCNAME[0]}

    if [[ -z $1 ]]; then
        write_to_screen_and_script_log "Please specify the tar file downloaded from Docker hub"
        print_version_and_exit 1
    fi

    if ! [[ -f $1 ]]; then
        write_to_screen_and_script_log "Tar file $1 does not exist"
        print_version_and_exit 1
    fi

    docker load < $1

    write_to_screen_and_script_log ">>> MetroAE container sucessfully loaded from tar file"
    write_to_screen_and_script_log "You can run 'metroae container setup' to setup"
}

function container_load_templates {
    debug ${FUNCNAME[0]}

    if [[ -z $1 ]]; then
        write_to_screen_and_script_log "Please specify the path to the tar file"
        print_version_and_exit 1
    fi

    if ! [[ -f $1 ]]; then
        write_to_screen_and_script_log "Tar file $1 does not exist"
        print_version_and_exit 1
    fi

    write_to_screen_and_script_log "Extracting template and specifications tarballs..."
    tar -xvf "$1"
    if [[ $? -ne 0 ]]; then
        write_to_screen_and_script_log "There was an issue extracting tarballs from $1"
        exit 1
    fi

    templates_filename=$(basename $TEMPLATE_TAR_LOCATION)
    specs_filename=$(basename $VSD_SPECIFICATIONS_LOCATION)

    template_path=$METROAE_MOUNT_POINT/$TEMPLATE_DIR
    mkdir -p "$template_path"
    write_to_screen_and_script_log "Extracting template files to $template_path..."
    tar -xvf "$templates_filename" -C $template_path
    if [[ $? -ne 0 ]]; then
        write_to_screen_and_script_log "There was an issue extracting template files from $templates_filename"
        exit 1
    fi

    specs_path=$METROAE_MOUNT_POINT/$SPECIFICATION_DIR
    mkdir -p "$specs_path"
    write_to_screen_and_script_log "Extracting specification files to $specs_path..."
    tar -xvf "$specs_filename" -C $specs_path
    if [[ $? -ne 0 ]]; then
        write_to_screen_and_script_log "There was an issue extracting VSD API Specifications from $specs_filename"
        exit 1
    fi

    write_to_screen_and_script_log "Templates and specifications have been extracted"
    write_to_screen_and_script_log "They can be found in $template_path and $specs_path"

    rm -f $templates_filename
    rm -f $specs_filename

    if [[ -e $templates_filename ]] || [[ -e $specs_filename ]]; then
        write_to_screen_and_script_log "Could not remove one or both of the intermediate tar files"
        write_to_screen_and_script_log "They can be found here: $templates_filename and $specs_filename"
        exit 1
    fi

    exit 0

}

#################################################################################
#                             CONTAINER DOWNLOAD                                #
#################################################################################

# The following code was adapted from the Moby project (under Apache 2 license)
# https://github.com/moby/moby/
# Specifically from the Docker hub download script
# https://raw.githubusercontent.com/moby/moby/master/contrib/download-frozen-image-v2.sh

function download_container {
    debug ${FUNCNAME[0]}

    if [[ -z $1 ]]; then
        imageTag=current
    else
        imageTag=$1
    fi

    set +e
    docker --version >> /dev/null 2>> /dev/null
    exitcode=$?
    set -e

    if [[ $exitcode -eq 0 ]]; then
        download_using_docker "$METRO_AE_IMAGE:$imageTag"
    else
        download_from_docker_hub "$METRO_AE_IMAGE:$imageTag"
    fi
}

function download_container_templates {
    debug ${FUNCNAME[0]}
    if ! command -v curl &> /dev/null; then
        write_to_screen_and_script_log "The command 'curl' was not found in PATH"
        write_to_screen_and_script_log "This is a small utility for downloading files from the Internet"
        write_to_screen_and_script_log "It is needed for downloading templates from Amazon S3"
        write_to_screen_and_script_log "Please install this utility with:"
        write_to_screen_and_script_log ""
        write_to_screen_and_script_log "sudo yum install curl"
        write_to_screen_and_script_log ""
        exit 1
    fi
    {
        curl -O $TEMPLATE_TAR_LOCATION &> /dev/null &&
        curl -O $VSD_SPECIFICATIONS_LOCATION &> /dev/null
    } || {
        echo "Warning: Internet connection not detected from the container."
        echo "MetroAE Config Templates and VSD Specification files were not downloaded."
        echo "Please exit the container first and download the tar files from the provided URLs below."
        echo "Download the MetroAE Config Template files from the following URL:"
        echo "$TEMPLATE_TAR_LOCATION"
        echo ""
        echo "Download the VSD Specification files from the following URL:"
        echo "$VSD_SPECIFICATIONS_LOCATION"
        echo "Upon successful download of the two tar files"
        echo "untar the files to: $METROAE_MOUNT_POINT"
        echo ""
        exit 0
    }
    template_tar_file=$(basename $TEMPLATE_TAR_LOCATION)
    specs_tar_file=$(basename $VSD_SPECIFICATIONS_LOCATION)
    template_and_specs_tar_file="metroae_templates_specs.tar"

    set +e
    tar -rf $template_and_specs_tar_file $template_tar_file $specs_tar_file
    tar_exit_code=$?
    set -e

    if [[ $tar_exit_code -eq 0 ]]; then
        write_to_screen_and_script_log "The latest MetroAE templates and VSD API Specifications have been downloaded"
        write_to_screen_and_script_log "They can be found in $template_and_specs_tar_file"
    else
        write_to_screen_and_script_log "There was an issue when archiving the tarballs, please try again."
        exit 1
    fi

    rm -f $template_tar_file
    rm -f $specs_tar_file

    if [[ -e $template_tar_file ]] || [[ -e $specs_tar_file ]]; then
        write_to_screen_and_script_log "Could not remove one or both of the intermediate tar files"
        write_to_screen_and_script_log "They can be found here: $template_tar_file and $specs_tar_file"
        exit 1
    fi

    exit 0
}

function download_using_docker {
    debug ${FUNCNAME[0]}

    write_to_screen_and_script_log ">>> Downloading $1 using docker"

    set +e
    docker save $1 > $CONTAINER_TAR_FILE
    exitcode=$?
    set -e

    if [[ $exitcode -eq 0 ]]; then
        write_to_screen_and_script_log "Download of images into '$CONTAINER_TAR_FILE' complete."
        echo "Copy this file to MetroAE Docker host and issue:"
        echo "  metroae container load $CONTAINER_TAR_FILE"
    else
        write_to_screen_and_script_log "Error using docker to download, trying directly from Docker hub..."
        download_from_docker_hub $1
    fi
}

function download_from_docker_hub {
    debug ${FUNCNAME[0]}

    write_to_screen_and_script_log ">>> Downloading $1 from Docker hub"

    check_download_requirements

    mkdir -p "$DOCKER_DOWNLOAD_WORK_DIR"

    # hacky workarounds for Bash 3 support (no associative arrays)
    images=()
    rm -f "$DOCKER_DOWNLOAD_WORK_DIR"/tags-*.tmp
    manifestJsonEntries=()
    doNotGenerateManifestJson=

    # bash v4 on Windows CI requires CRLF separator... and linux doesn't seem to care either way
    newlineIFS=$'\n'
    major=$(echo "${BASH_VERSION%%[^0.9]}" | cut -d. -f1)
    if [ "$major" -ge 4 ]; then
        newlineIFS=$'\r\n'
    fi

    imageTag="$1"

    image="${imageTag%%[:@]*}"
    imageTag="${imageTag#*:}"
    digest="${imageTag##*@}"
    tag="${imageTag%%@*}"

    # add prefix library if passed official image
    if [[ "$image" != *"/"* ]]; then
        image="library/$image"
    fi

    imageFile="${image//\//_}" # "/" can't be in filenames :)

    token="$(curl -fsSL "$DOCKER_AUTH_BASE/token?service=$DOCKER_AUTH_SERVICE&scope=repository:$image:pull" | jq --raw-output '.token')"

    manifestJson="$(
        curl -fsSL \
            -H "Authorization: Bearer $token" \
            -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' \
            -H 'Accept: application/vnd.docker.distribution.manifest.list.v2+json' \
            -H 'Accept: application/vnd.docker.distribution.manifest.v1+json' \
            "$DOCKER_REGISTRY_BASE/v2/$image/manifests/$digest"
    )"
    if [ "${manifestJson:0:1}" != '{' ]; then
        write_to_screen_and_script_log "error: /v2/$image/manifests/$digest returned something unexpected:"
        write_to_screen_and_script_log "  $manifestJson"
        exit 1
    fi

    imageIdentifier="$image:$tag@$digest"

    schemaVersion="$(echo "$manifestJson" | jq --raw-output '.schemaVersion')"
    case "$schemaVersion" in
        2)
            mediaType="$(echo "$manifestJson" | jq --raw-output '.mediaType')"

            case "$mediaType" in
                application/vnd.docker.distribution.manifest.v2+json)
                    handle_single_manifest_v2 "$manifestJson"
                    ;;
                application/vnd.docker.distribution.manifest.list.v2+json)
                    layersFs="$(echo "$manifestJson" | jq --raw-output --compact-output '.manifests[]')"
                    IFS="$newlineIFS"
                                        while IFS= read -r line; do
                                            layers+=("$line")
                                        done <<< "$layersFs"
                    unset IFS

                    found=""
                    targetArch="$(get_target_arch)"
                    # parse first level multi-arch manifest
                    for i in "${!layers[@]}"; do
                        layerMeta="${layers[$i]}"
                        maniArch="$(echo "$layerMeta" | jq --raw-output '.platform.architecture')"
                        if [ "$maniArch" = "${targetArch}" ]; then
                            digest="$(echo "$layerMeta" | jq --raw-output '.digest')"
                            # get second level single manifest
                            submanifestJson="$(
                                curl -fsSL \
                                    -H "Authorization: Bearer $token" \
                                    -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' \
                                    -H 'Accept: application/vnd.docker.distribution.manifest.list.v2+json' \
                                    -H 'Accept: application/vnd.docker.distribution.manifest.v1+json' \
                                    "$DOCKER_REGISTRY_BASE/v2/$image/manifests/$digest"
                            )"
                            handle_single_manifest_v2 "$submanifestJson"
                            found="found"
                            break
                        fi
                    done
                    if [ -z "$found" ]; then
                        write_to_screen_and_script_log "error: manifest for $maniArch is not found"
                        exit 1
                    fi
                    ;;
                *)
                    write_to_screen_and_script_log "error: unknown manifest mediaType ($imageIdentifier): '$mediaType'"
                    exit 1
                    ;;
            esac
            ;;

        1)
            if [ -z "$doNotGenerateManifestJson" ]; then
                write_to_screen_and_script_log "warning: '$imageIdentifier' uses schemaVersion '$schemaVersion'"
                write_to_screen_and_script_log "  this script cannot (currently) recreate the 'image config' to put in a 'manifest.json' (thus any schemaVersion 2+ images will be imported in the old way, and their 'docker history' will suffer)"
                write_to_screen_and_script_log
                doNotGenerateManifestJson=1
            fi

            layersFs="$(echo "$manifestJson" | jq --raw-output '.fsLayers | .[] | .blobSum')"
            IFS="$newlineIFS"
                        while IFS= read -r line; do
                            layers+=("$line")
                        done <<< "$layersFs"
            unset IFS

            history="$(echo "$manifestJson" | jq '.history | [.[] | .v1Compatibility]')"
            imageId="$(echo "$history" | jq --raw-output '.[0]' | jq --raw-output '.id')"

            echo "Downloading '$imageIdentifier' (${#layers[@]} layers)..."
            for i in "${!layers[@]}"; do
                imageJson="$(echo "$history" | jq --raw-output ".[${i}]")"
                layerId="$(echo "$imageJson" | jq --raw-output '.id')"
                imageLayer="${layers[$i]}"

                mkdir -p "$DOCKER_DOWNLOAD_WORK_DIR/$layerId"
                echo '1.0' > "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/VERSION"

                echo "$imageJson" > "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/json"

                # TODO figure out why "-C -" doesn't work here
                # "curl: (33) HTTP server doesn't seem to support byte ranges. Cannot resume."
                # "HTTP/1.1 416 Requested Range Not Satisfiable"
                if [ -f "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/layer.tar" ]; then
                    # TODO hackpatch for no -C support :'(
                    echo "skipping existing ${layerId:0:12}"
                    continue
                fi
                token="$(curl -fsSL "$DOCKER_AUTH_BASE/token?service=$DOCKER_AUTH_SERVICE&scope=repository:$image:pull" | jq --raw-output '.token')"
                fetch_blob "$token" "$image" "$imageLayer" "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/layer.tar" --progress-bar
            done
            ;;

        *)
            write_to_screen_and_script_log "error: unknown manifest schemaVersion ($imageIdentifier): '$schemaVersion'"
            exit 1
            ;;
    esac

    echo

    if [ -s "$DOCKER_DOWNLOAD_WORK_DIR/tags-$imageFile.tmp" ]; then
        echo -n ', ' >> "$DOCKER_DOWNLOAD_WORK_DIR/tags-$imageFile.tmp"
    else
        images=("${images[@]}" "$image")
    fi
    echo -n '"'"$tag"'": "'"$imageId"'"' >> "$DOCKER_DOWNLOAD_WORK_DIR/tags-$imageFile.tmp"

    echo -n '{' > "$DOCKER_DOWNLOAD_WORK_DIR/repositories"
    firstImage=1
    for image in "${images[@]}"; do
        imageFile="${image//\//_}" # "/" can't be in filenames :)
        image="${image#library\/}"

        [ "$firstImage" ] || echo -n ',' >> "$DOCKER_DOWNLOAD_WORK_DIR/repositories"
        firstImage=
        echo -n $'\n\t' >> "$DOCKER_DOWNLOAD_WORK_DIR/repositories"
        echo -n '"'"$image"'": { '"$(cat "$DOCKER_DOWNLOAD_WORK_DIR/tags-$imageFile.tmp")"' }' >> "$DOCKER_DOWNLOAD_WORK_DIR/repositories"
    done
    echo -n $'\n}\n' >> "$DOCKER_DOWNLOAD_WORK_DIR/repositories"

    rm -f "$DOCKER_DOWNLOAD_WORK_DIR"/tags-*.tmp

    if [ -z "$doNotGenerateManifestJson" ] && [ "${#manifestJsonEntries[@]}" -gt 0 ]; then
        echo '[]' | jq --raw-output ".$(for entry in "${manifestJsonEntries[@]}"; do echo " + [ $entry ]"; done)" > "$DOCKER_DOWNLOAD_WORK_DIR/manifest.json"
    else
        rm -f "$DOCKER_DOWNLOAD_WORK_DIR/manifest.json"
    fi


    tar -cC $DOCKER_DOWNLOAD_WORK_DIR . > $CONTAINER_TAR_FILE
    rm -rf $DOCKER_DOWNLOAD_WORK_DIR
    write_to_screen_and_script_log "Download of images into '$CONTAINER_TAR_FILE' complete."
    echo "Copy this file to MetroAE Docker host and issue:"
    echo "  metroae container load $CONTAINER_TAR_FILE"

}

function check_download_requirements {
    debug ${FUNCNAME[0]}

    # check if essential commands are in our PATH
    all_commands_present=1

    if ! command -v jq &> /dev/null; then
        write_to_screen_and_script_log "The command 'jq' was not found in PATH"
        write_to_screen_and_script_log "This is a small utility for parsing JSON output"
        write_to_screen_and_script_log "It is needed for parsing Docker hub manifest output"
        write_to_screen_and_script_log "Please install this utility with:"
        write_to_screen_and_script_log ""
        write_to_screen_and_script_log "sudo yum install jq"
        write_to_screen_and_script_log ""
        all_commands_present=0
    fi

    if ! command -v curl &> /dev/null; then
        write_to_screen_and_script_log "The command 'curl' was not found in PATH"
        write_to_screen_and_script_log "This is a small utility for downloading files from the Internet"
        write_to_screen_and_script_log "It is needed for downloading files from Docker hub"
        write_to_screen_and_script_log "Please install this utility with:"
        write_to_screen_and_script_log ""
        write_to_screen_and_script_log "sudo yum install curl"
        write_to_screen_and_script_log ""
        all_commands_present=0
    fi

    if ! command -v sha256sum &> /dev/null; then
        write_to_screen_and_script_log "The command 'sha256sum' was not found in PATH"
        write_to_screen_and_script_log "This is a small utility for calculating SHA256 checksums"
        write_to_screen_and_script_log "It is needed for validating files downloaded from Docker hub"
        write_to_screen_and_script_log "Please install this utility with:"
        write_to_screen_and_script_log ""
        write_to_screen_and_script_log "sudo yum install coreutils"
        write_to_screen_and_script_log ""
        all_commands_present=0
    fi

    if [[ $all_commands_present -ne 1 ]]; then
        print_version_and_exit 1
    fi
}

fetch_blob() {
    debug ${FUNCNAME[0]}

    local token="$1"
    shift
    local image="$1"
    shift
    local digest="$1"
    shift
    local targetFile="$1"
    shift
    local curlArgs=("$@")

    local curlHeaders
    curlHeaders="$(
        curl -S "${curlArgs[@]}" \
            -H "Authorization: Bearer $token" \
            "$DOCKER_REGISTRY_BASE/v2/$image/blobs/$digest" \
            -o "$targetFile" \
            -D-
    )"
    curlHeaders="$(echo "$curlHeaders" | tr -d '\r')"
    if grep -qE "^HTTP/[0-9].[0-9] 3" <<< "$curlHeaders"; then
        rm -f "$targetFile"

        local blobRedirect
        blobRedirect="$(echo "$curlHeaders" | awk -F ': ' 'tolower($1) == "location" { print $2; exit }')"
        if [ -z "$blobRedirect" ]; then
            write_to_screen_and_script_log "error: failed fetching '$image' blob '$digest'"
            echo "$curlHeaders" | head -1 >&2
            return 1
        fi

        curl -fSL "${curlArgs[@]}" \
            "$blobRedirect" \
            -o "$targetFile"
    fi
}

# handle 'application/vnd.docker.distribution.manifest.v2+json' manifest
handle_single_manifest_v2() {
    debug ${FUNCNAME[0]}

    local manifestJson="$1"
    shift

    local configDigest
    configDigest="$(echo "$manifestJson" | jq --raw-output '.config.digest')"
    local imageId="${configDigest#*:}" # strip off "sha256:"

    local configFile="$imageId.json"
    fetch_blob "$token" "$image" "$configDigest" "$DOCKER_DOWNLOAD_WORK_DIR/$configFile" -s

    local layersFs
    layersFs="$(echo "$manifestJson" | jq --raw-output --compact-output '.layers[]')"
    local IFS="$newlineIFS"
    local layers
        while IFS= read -r line; do
            layers+=("$line")
        done <<< "$layersFs"
    unset IFS

    echo "Downloading '$imageIdentifier' (${#layers[@]} layers)..."
    local layerId=
    local layerFiles=()
    for i in "${!layers[@]}"; do
        local layerMeta="${layers[$i]}"

                if [[ -z $layerMeta ]]; then
                    continue
                fi

        local layerMediaType
        layerMediaType="$(echo "$layerMeta" | jq --raw-output '.mediaType')"
        local layerDigest
        layerDigest="$(echo "$layerMeta" | jq --raw-output '.digest')"

        # save the previous layer's ID
        local parentId="$layerId"
        # create a new fake layer ID based on this layer's digest and the previous layer's fake ID
        layerId="$(echo "$parentId"$'\n'"$layerDigest" | sha256sum | cut -d' ' -f1)"
        # this accounts for the possibility that an image contains the same layer twice (and thus has a duplicate digest value)

        mkdir -p "$DOCKER_DOWNLOAD_WORK_DIR/$layerId"
        echo '1.0' > "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/VERSION"

        if [ ! -s "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/json" ]; then
            local parentJson
            parentJson="$(printf ', parent: "%s"' "$parentId")"
            local addJson
            addJson="$(printf '{ id: "%s"%s }' "$layerId" "${parentId:+$parentJson}")"
            # this starter JSON is taken directly from Docker's own "docker save" output for unimportant layers
            jq "$addJson + ." > "$DOCKER_DOWNLOAD_WORK_DIR/$layerId/json" << EOJSON
                {
                    "created": "0001-01-01T00:00:00Z",
                    "container_config": {
                        "Hostname": "",
                        "Domainname": "",
                        "User": "",
                        "AttachStdin": false,
                        "AttachStdout": false,
                        "AttachStderr": false,
                        "Tty": false,
                        "OpenStdin": false,
                        "StdinOnce": false,
                        "Env": null,
                        "Cmd": null,
                        "Image": "",
                        "Volumes": null,
                        "WorkingDir": "",
                        "Entrypoint": null,
                        "OnBuild": null,
                        "Labels": null
                    }
                }
EOJSON
# ^^ Do not indent or put anything else on previous line (multiline block string)
        fi

        case "$layerMediaType" in
            application/vnd.docker.image.rootfs.diff.tar.gzip)
                local layerTar="$layerId/layer.tar"
                layerFiles=("${layerFiles[@]}" "$layerTar")
                # TODO figure out why "-C -" doesn't work here
                # "curl: (33) HTTP server doesn't seem to support byte ranges. Cannot resume."
                # "HTTP/1.1 416 Requested Range Not Satisfiable"
                if [ -f "$DOCKER_DOWNLOAD_WORK_DIR/$layerTar" ]; then
                    # TODO hackpatch for no -C support :'(
                    echo "skipping existing ${layerId:0:12}"
                    continue
                fi
                local token
                token="$(curl -fsSL "$DOCKER_AUTH_BASE/token?service=$DOCKER_AUTH_SERVICE&scope=repository:$image:pull" | jq --raw-output '.token')"
                fetch_blob "$token" "$image" "$layerDigest" "$DOCKER_DOWNLOAD_WORK_DIR/$layerTar" --progress-bar
                ;;

            *)
                write_to_screen_and_script_log "error: unknown layer mediaType ($imageIdentifier, $layerDigest): '$layerMediaType'"
                exit 1
                ;;
        esac
    done

    # change "$imageId" to be the ID of the last layer we added (needed for old-style "repositories" file which is created later -- specifically for older Docker daemons)
    imageId="$layerId"

    # munge the top layer image manifest to have the appropriate image configuration for older daemons
    local imageOldConfig
    imageOldConfig="$(jq --raw-output --compact-output '{ id: .id } + if .parent then { parent: .parent } else {} end' "$DOCKER_DOWNLOAD_WORK_DIR/$imageId/json")"
    jq --raw-output "$imageOldConfig + del(.history, .rootfs)" "$DOCKER_DOWNLOAD_WORK_DIR/$configFile" > "$DOCKER_DOWNLOAD_WORK_DIR/$imageId/json"

    local manifestJsonEntry
    manifestJsonEntry="$(
        echo '{}' | jq --raw-output '. + {
            Config: "'"$configFile"'",
            RepoTags: ["'"${image#library\/}:$tag"'"],
            Layers: '"$(echo '[]' | jq --raw-output ".$(for layerFile in "${layerFiles[@]}"; do echo " + [ \"$layerFile\" ]"; done)")"'
        }'
    )"
    manifestJsonEntries=("${manifestJsonEntries[@]}" "$manifestJsonEntry")
}

get_target_arch() {
    debug ${FUNCNAME[0]}

    if [ -n "${TARGETARCH:-}" ]; then
        echo "${TARGETARCH}"
        return 0
    fi

    if type go > /dev/null; then
        go env GOARCH
        return 0
    fi

    if type dpkg > /dev/null; then
        debArch="$(dpkg --print-architecture)"
        case "${debArch}" in
            armel | armhf)
                echo "arm"
                return 0
                ;;
            *64el)
                echo "${debArch%el}le"
                return 0
                ;;
            *)
                echo "${debArch}"
                return 0
                ;;
        esac
    fi

    if type uname > /dev/null; then
        uArch="$(uname -m)"
        case "${uArch}" in
            x86_64)
                echo amd64
                return 0
                ;;
            arm | armv[0-9]*)
                echo arm
                return 0
                ;;
            aarch64)
                echo arm64
                return 0
                ;;
            mips*)
                write_to_screen_and_script_log "I see you are running on mips but I don't know how to determine endianness yet, so I cannot select a correct arch to fetch."
                write_to_screen_and_script_log "Consider installing \"go\" on the system which I can use to determine the correct arch or specify it explictly by setting TARGETARCH"
                exit 1
                ;;
            *)
                echo "${uArch}"
                return 0
                ;;
        esac

    fi

    # default value
    write_to_screen_and_script_log "Unable to determine CPU arch, falling back to amd64. You can specify a target arch by setting TARGETARCH"
    echo amd64
}


#################################################################################
#                                 DEPLOYMENT                                    #
#################################################################################

function list_workflows {
    debug ${FUNCNAME[0]}
    for file in $PLAYBOOK_DIR/*.yml
    do
        if [[ -f $file ]]; then
            filename=$(basename "$file")
            filename="${filename%.*}"
            echo $filename
        fi
    done
    for file in $PLAYBOOK_WITH_BUILD_DIR/*.yml
    do
        if [[ -f $file ]]; then
            filename=$(basename "$file")
            filename="${filename%.*}"
            echo $filename
        fi
    done
}

function check_password_needed {
    debug ${FUNCNAME[0]}
    deployment_dir="$1"

    encrypted_files=$(grep -Ril $ENCRYPTED_TOKEN $deployment_dir)

    if [[ -z $METROAE_PASSWORD ]]; then
        if [[ -z "$encrypted_files" ]]; then
            SKIP_PASSWORD=1
        else
            SKIP_PASSWORD=0
        fi
    else
        SKIP_PASSWORD=1
    fi
}

function ask_password {
    debug ${FUNCNAME[0]}
    if [[ $SKIP_PASSWORD -ne 1 ]]; then
        write_to_screen_and_script_log "The deployment contains encrypted content which requires a password to access."
        echo "Enter the password, below, or add the environment variable METROAE_PASSWORD and retry."
        echo ""
        read -s -p "Enter password: " METROAE_PASSWORD
        export METROAE_PASSWORD
    fi
}

function write_audit_log_entry {
    debug ${FUNCNAME[0]}
    echo "`date` MetroAE $METROAE_VERSION $ORIGINAL_ARGS" >> $AUDIT_LOG
}

function audit_log_and_exit {
    debug ${FUNCNAME[0]}
    echo "`date` MetroAE $METROAE_VERSION exit code $1" >> $AUDIT_LOG
    print_version_and_exit $1
}

function deployment_main {
    generate_and_save_UUID

    debug ${FUNCNAME[0]}
    set +e

    ORIGINAL_ARGS="$*"

    #
    # Parse arguments
    #
    SKIP_BUILD=0
    SKIP_PASSWORD=0
    POSITIONAL=()
    while [[ $# -gt 0 ]]
    do
    key="$1"

    case $key in
        -h|--help)
        main_help
        print_version_and_exit 0
        ;;
        -v|--version)
        help_header
        print_version_and_exit 0
        ;;
        --ansible-help)
        $(which ansible-playbook) --help
        print_version_and_exit 0
        ;;
        --list)
        list_workflows
        print_version_and_exit 0
        ;;
        --set-group)
        GROUP="$2"
        touch ansible.log
        chgrp $GROUP ansible.log
        touch $AUDIT_LOG
        chgrp $GROUP $AUDIT_LOG
        shift # past argument
        shift # past value
        ;;
        --skip-build)
        SKIP_BUILD=1
        shift # past argument
        ;;
        --skip-password)
        SKIP_PASSWORD=1
        shift # past argument
        ;;
        *)    # unknown option
        POSITIONAL+=("$1") # save it in an array for later
        shift # past argument
        ;;
    esac
    done
    set -- "${POSITIONAL[@]}" # restore positional parameters

    # Missing workflow, show usage
    if [[ $# -eq 0 ]] || [[ $1 == -* ]]; then
        main_help
        print_version_and_exit 1
    fi

    # <workflow> argument
    WORKFLOW=$1
    debug "${FUNCNAME[0]}: WORKFLOW = @WORKFLOW"

    # Add .yml extension if needed
    EXTENSION="${WORKFLOW##*.}"
    if [[ "$EXTENSION" != "yml" ]]; then
        WORKFLOW=${WORKFLOW}.yml
    fi

    if [[ ! -a $PLAYBOOK_DIR/$WORKFLOW  ]] && [[ ! -a $PLAYBOOK_WITH_BUILD_DIR/$WORKFLOW ]]; then
        write_to_screen_and_script_log "Requested MetroAE workflow ($1) could not be found"
        print_version_and_exit 1
    fi
    shift

    # [deployment] argument
    if [[ $# -gt 0 ]]; then
        if [[ $1 != -* ]]; then
            DEPLOYMENT="$1"
            shift
            if [[ $DEPLOYMENT == *.csv ]]; then
                filename=$(basename -- "$DEPLOYMENT")
                deployment_name="${filename%.*}"
                DEPLOYMENT_DIR="$DEPLOYMENTS_BASE_DIR/$deployment_name"
                rm -f $DEPLOYMENT_DIR/*.yml
                ./convert_csv_to_deployment.py $DEPLOYMENT $deployment_name
            elif [[ $DEPLOYMENT == *.xlsx ]]; then
                filename=$(basename -- "$DEPLOYMENT")
                deployment_name="${filename%.*}"
                DEPLOYMENT_DIR="$DEPLOYMENTS_BASE_DIR/$deployment_name"
                rm -f $DEPLOYMENT_DIR/*.yml
                ./convert_excel_to_deployment.py $DEPLOYMENT $deployment_name
            elif [[ -d $DEPLOYMENT ]]; then
                DEPLOYMENT_DIR=$DEPLOYMENT
            elif [[ -d $DEPLOYMENTS_BASE_DIR/$DEPLOYMENT ]]; then
                DEPLOYMENT_DIR=$DEPLOYMENTS_BASE_DIR/$DEPLOYMENT
            else
            write_to_screen_and_script_log "Could not find deployment '$DEPLOYMENT' under $DEPLOYMENTS_BASE_DIR"
            print_version_and_exit 1
            fi
        fi
    fi

    # Get password if needed
    check_password_needed "$DEPLOYMENT_DIR"
    ask_password
    if [[ ! -z $METROAE_PASSWORD ]]; then
        export ANSIBLE_VAULT_PASSWORD_FILE=$VAULT_ENV_FILE
    fi

    # Run playbooks
    if [[ -a $PLAYBOOK_DIR/$WORKFLOW  ]]; then
        write_audit_log_entry
        $(which ansible-playbook) -e deployment_dir=\'"$DEPLOYMENT_DIR"\' -e schema_dir=$SCHEMA_DIR $PLAYBOOK_DIR/$WORKFLOW "$@" || audit_log_and_exit $?
    elif [[ -a $PLAYBOOK_WITH_BUILD_DIR/$WORKFLOW ]]; then
        write_audit_log_entry
        phone_home_args=("\"UUID\":\"${UUID}\"" "\"Actions\":\"${WORKFLOW}\"" "\"Mode\":\"${RUN_MODE}\"" "\"timestamp\":\"$(date)\"" "\"Version\":\"${METROAE_VERSION}\"")
        phone_home "${phone_home_args[@]}"
        if [[ $SKIP_BUILD -ne 1 ]]; then
            $(which ansible-playbook) -e deployment_dir=\'"$DEPLOYMENT_DIR"\' -e schema_dir=$SCHEMA_DIR $PLAYBOOK_DIR/build.yml "$@" || audit_log_and_exit $?
            if [[ $GROUP ]]; then chgrp -R $GROUP $INVENTORY_DIR; fi
        fi
        $(which ansible-playbook) $PLAYBOOK_WITH_BUILD_DIR/$WORKFLOW "$@" || audit_log_and_exit $?
    else
        write_to_screen_and_script_log "Requested MetroAE workflow ($WORKFLOW) could not be found"
        print_version_and_exit 1
    fi

    audit_log_and_exit 0

    set -e

}

#################################################################################
#                                    Config                                     #
#################################################################################

function docker_exec_config {
    debug ${FUNCNAME[0]}
    docker_exec env /usr/bin/python $CONTAINER_HOME/nuage-metroae-config/metroae_config.py "$@"
}

function docker_exec_generate_and_copy_keys {
    debug ${FUNCNAME[0]}
    docker_exec env $CONTAINER_HOME/generateAndCopySshKeys.sh
}

function docker_exec_copy_common_defaults {
    debug ${FUNCNAME[0]}
    docker_exec env $CONTAINER_HOME/copyCommonDefaults.sh
}

function docker_exec_copy_deploy_defaults {
    debug ${FUNCNAME[0]}
    docker_exec env $CONTAINER_HOME/copyDeployDefaults.sh
}

function docker_exec_copy_config_defaults {
    debug ${FUNCNAME[0]}
    docker_exec env $CONTAINER_HOME/copyConfigDefaults.sh
}

function config_status {
    debug ${FUNCNAME[0]}
    container_status
}

function config_main {
    debug ${FUNCNAME[0]}

    check_docker

    check_for_user_group

    if [[ $# -eq 0 ]]; then
        config_help ",config"
        exit 0
    fi

    shopt -s extglob
    POSITIONAL=()
    exec=false
    usage_last=false
    no_arguments=$#
    while [[ $# -gt 0 ]]
    do
        key=$1
        case "$key" in
            help|--h|-h|--help|-help)

            get_running_container_id
            if [[ -z $RUNNING_CONTAINER_ID ]]; then
                config_help ",config"
            else
                if [[ $no_arguments -lt 2 ]]; then
                    usage_last=true
                fi
            fi
            POSITIONAL+=("$1")
            exec=true
            shift
            ;;
            pull)
            if [[ -z $2 ]]; then
                pull
            else
                pull $2
                shift
            fi
            shift
            ;;
            setup)
            if [[ -z $2 ]]; then
                setup
            else
                setup $2
                shift
            fi
            shift
            ;;
            start)
            run_container
            shift
            ;;
            stop)
            stop_running_container
            shift
            ;;
            destroy)
            if [[ -z $2 ]]; then
                destroy
            else
                destroy $2
                shift
            fi
            shift
            ;;
            upgrade-engine)
            if [[ -z $2 ]]; then
                update_container
            else
                shift
                update_container $*
            fi
            exit 0
            ;;
            interactive)
            interactive
            shift
            ;;
            status)
            config_status
            shift
            ;;
            *)
            POSITIONAL+=("$1")
            exec=true
            shift
            ;;
        esac
    done

    generate_and_save_UUID

    if [[ $exec == true ]]; then
        phone_home_args=("\"UUID\":\"${UUID}\"" "\"Actions\":\"${POSITIONAL[1]}\"" "\"Mode\":\"${RUN_MODE}\"" "\"timestamp\":\"$(date)\"" "\"Version\":\"${METROAE_VERSION}\"")
        phone_home "${phone_home_args[@]}"
        docker_exec_config "${POSITIONAL[@]}"
    fi

    if [[ $usage_last == true ]]; then
        config_help ",config"
    fi

}

#################################################################################
#                                  Container                                    #
#################################################################################

function copy_ssh_id {
    debug ${FUNCNAME[0]}
    if [[ -z $1 ]]; then
        echo "Usage: metroae tools ssh copyid <user@hostname>"
        print_version_and_exit 1
    fi
    run_container_if_not_running

    sshpass=" "
    if [[ ! -z $SSHPASS_PASSWORD ]]; then
       sshpass="sshpass -p$SSHPASS_PASSWORD"
    fi
    if [[ ! -z $NOT_INTERACTIVE ]]; then
       docker exec $RUNNING_CONTAINER_ID $sshpass ssh-copy-id -i $CONTAINER_HOME/id_rsa.pub -o StrictHostKeyChecking=no $1
    else
       docker exec -it $RUNNING_CONTAINER_ID $sshpass ssh-copy-id -i $CONTAINER_HOME/id_rsa.pub -o StrictHostKeyChecking=no $1
    fi
}

function docker_metro_ae_exec {
    debug ${FUNCNAME[0]}
    docker_exec env $CONTAINER_HOME/nuage-metroae/metroae "$@"
}

function unzip_files {
    debug ${FUNCNAME[0]}
    docker_exec $CONTAINER_HOME/nuage-metroae/nuage-unzip.sh "$@"
}

function gen_example_from_schema {
    debug ${FUNCNAME[0]}
    docker_exec /usr/bin/python $CONTAINER_HOME/nuage-metroae/generate_example_from_schema.py "$@"
}

function container_status {
    debug ${FUNCNAME[0]}
    get_running_container_id
    if [[ ! -z $RUNNING_CONTAINER_ID ]]; then
        write_to_screen_and_script_log "MetroAE Container Status:"
        echo ""
        debug "${FUNCNAME[0]}: Getting the versions in the container itself"
        docker exec $RUNNING_CONTAINER_ID cat $CONTAINER_HOME/version
    else
        echo ""
        write_to_screen_and_script_log "The MetroAE container is not running."
        echo "Please run 'metroae container start' to restart a stopped container."
        echo "Please run 'metroae container setup' to setup a container. Quitting."
        echo ""
        exit 0
    fi
    if [[ -f $SETUP_FILE ]]; then
        debug "${FUNCNAME[0]}: Using container configuration from host"
        if [[ -z $METROAE_SETUP_TYPE ]]; then
            echo ""
            write_to_screen_and_script_log "We couldn't find the MetroAE setup type in the configuration file on disk."
            echo "Please run 'metroae container setup' and try again."
            echo ""
            print_version_and_exit 1
        elif [[ -z $METROAE_MOUNT_POINT ]]; then
            echo ""
            write_to_screen_and_script_log "We couldn't find the MetroAE data path in the configuration file on disk."
            echo "Please run 'metroae container setup' and try again."
            echo ""
            print_version_and_exit 1
        fi
        if [[ $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
            current_setup_type="Config"
        elif [[ $METROAE_SETUP_TYPE == $DEPLOY_SETUP_TYPE ]]; then
            current_setup_type="Deploy"
        elif [[ $METROAE_SETUP_TYPE == $BOTH_SETUP_TYPE ]]; then
            current_setup_type="Both Config and Deploy"
        else
            echo ""
            write_to_screen_and_script_log "The MetroAE setup type in the configuration file on disk is not valid."
            echo "Please run 'metroae container setup' and try again."
            echo ""
        fi
        write_to_screen_and_script_log "MetroAE setup type: $current_setup_type"
        write_to_screen_and_script_log "MetroAE container data directory: $METROAE_MOUNT_POINT"
        write_to_screen_and_script_log "MetroAE run mode: $RUN_MODE"
    else
        echo ""
        write_to_screen_and_script_log "MetroAE container setup file not found. Please run 'metroae container setup'"
        echo "and try again. Quitting."
        echo ""
        print_version_and_exit 1
    fi
    if [[ ! -z $RUNNING_CONTAINER_ID ]]; then
        write_to_screen_and_script_log "Docker information:"
        echo ""
        debug "${FUNCNAME[0]}: Getting the output of 'docker ps'"
        header=`docker ps -a | grep "IMAGE"`
        write_to_screen_and_script_log "$header"
        container_status=`docker ps -a | grep "$METRO_AE_IMAGE"`
        write_to_screen_and_script_log "$container_status"
    fi
}

function vault_password {
    debug ${FUNCNAME[0]}
    run_container_if_not_running

    docker_exec_interactive /usr/bin/python $CONTAINER_HOME/nuage-metroae/encrypt_credentials.py  $1
}

function disable_encryption {
    debug ${FUNCNAME[0]}
    run_container_if_not_running
    docker exec $RUNNING_CONTAINER_ID $CONTAINER_HOME/UI.sh disable-encryption
}

function container_main {
    debug ${FUNCNAME[0]}
    if [[ ! -z $GROUP_CHECK ]]; then
        debug "${FUNCNAME[0]} GROUP_CHECK is defined"
        check_for_user_group "$@"
        shift
        print_version_and_exit 0
    else
        debug "${FUNCNAME[0]} GROUP_CHECK is not defined"
        check_for_user_group "$@"
    fi

    check_docker

    if [[ $# -eq 0 ]]; then
        container_help ",container"
        exit 0
    fi

    shopt -s extglob

    POSITIONAL=()
    exec=false
    debug "${FUNCNAME[0]}: Checking command options"
    while [ $# -gt 0 ]
    do
        key=$1
        debug "POSITIONAL = ${POSITIONAL[*]}"
        case $key in
            help|--h|-h|--help|-help)
            container_help ",container"
            POSITIONAL+=("$1")
            exec=true
            shift
            ;;
            pull)
            if [[ -z $2 ]]; then
                pull
            else
                pull $2
                shift
            fi
            shift
            ;;
            start)
            run_container
            shift
            ;;
            setup)
            num_params=$#
            if [[ num_params -gt 1 ]]; then
                shift
                setup_container "$@"
                for (( i=1; i<$num_params; i+=1 )); do
                    shift
                done
            else
                shift
                setup_container
            fi
            ;;
            stop)
            stop_running_container
            shift
            ;;
            destroy)
            if [[ -z $2 ]]; then
                destroy
            else
                destroy $2
                shift
            fi
            shift
            ;;
            upgrade-engine)
            if [[ -z $2 ]]; then
                update_container
            else
                shift
                update_container $*
            fi
            exit 0
            ;;
            status)
            container_status
            shift
            ;;
            encrypt-credentials)
            if [[ -z $2 ]]; then
                vault_password
            else
                vault_password $2
                shift
            fi
            shift
            ;;
            interactive)
            interactive
            shift
            ;;
            unzip-files)
            shift
            unzip_files "$@"
            print_version_and_exit 0
            ;;
            generate-example-from-schema)
            shift
            gen_example_from_schema "$@"
            print_version_and_exit 0
            ;;
            copy-ssh-id)
            copy_ssh_id "$2"
            shift
            shift
            ;;
            load)
            shift
            container_load "$@"
            print_version_and_exit 0
            ;;
            load-templates)
            shift
            container_load_templates "$@"
            print_version_and_exit 0
            ;;
            *)
            POSITIONAL+=("$1")
            exec=true
            shift
            ;;
        esac
    done

    if [[ $exec == true ]]; then
        if [[ $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
            echo ""
            write_to_screen_and_script_log "Unrecognized command for a config-only setup: ${POSITIONAL[@]}."
            echo "Execute 'metroae container setup' to change your setup type."
            echo ""
            echo ""
            main_help
        else
            docker_metro_ae_exec "${POSITIONAL[@]}"
        fi
    fi
}

#################################################################################
#                                   Plugins                                     #
#################################################################################

function copy_plugin_file_into_mount_point_if_necessary {
    debug ${FUNCNAME[0]}
    read_setup_files
    local plugin_path=${PLUGIN_INSTALL_ARGS[0]}
    mkdir -p $METROAE_MOUNT_POINT/metro_plugins
    if [[ -d $plugin_path ]]; then
        debug "${FUNCNAME[0]}: recursive copy from $plugin_path to $METROAE_MOUNT_POINT/metro_plugins/"
        cp -r $plugin_path $METROAE_MOUNT_POINT/metro_plugins/
    elif [[ -f $plugin_path ]]; then
        debug "${FUNCNAME[0]}: non-recursive copy from $plugin_path to $METROAE_MOUNT_POINT/metro_plugins/"
        cp $plugin_path $METROAE_MOUNT_POINT/metro_plugins/
    fi
    local container_plugin_path=/metroae_data/metro_plugins/$(basename "$plugin_path")
    debug "${FUNCNAME[0]}: Modified plugin path is $container_plugin_path"
    PLUGIN_INSTALL_ARGS[0]=$container_plugin_path
}

function version_compare {
    debug ${FUNCNAME[0]}
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

function get_plugin_name {
    debug ${FUNCNAME[0]}
    set +e
    local plugin_line=`grep plugin_name $1/plugin-cfg.yml`

    if [[ $? -ne 0 ]]
    then
        write_to_screen_and_script_log "Plugin missing or corrupt plugin-cfg.yml"
        print_version_and_exit 1
    fi
    plugin_name=`echo $plugin_line | awk '{ print $2 }'`
    set -e
}

function check_plugin_version {
    debug ${FUNCNAME[0]}
    set +e
    local plugin_line=`grep required_metro_version $1/plugin-cfg.yml`

    if [[ $? -ne 0 ]]
    then
        write_to_screen_and_script_log "Plugin missing or corrupt plugin-cfg.yml"
        print_version_and_exit 1
    fi

    local plugin_version=`echo $plugin_line | awk '{ print $2 }'`

    version_compare $plugin_version ${METROAE_VERSION#"v"}
    if [[ $? -eq 1 ]]
    then
        write_to_screen_and_script_log "Plugin requires MetroAE version $plugin_version"
        print_version_and_exit 1
    fi
    set -e

}

function check_plugin_files {
    debug ${FUNCNAME[0]}
    for file in $1/*
    do
        #echo $file
        if [[ -d $file ]]
        then
            check_plugin_files $file $2 $3
        elif [[ -f $file ]]
        then
            local base_file=${file#$2/}
            if [[ -f $3/$base_file ]]
            then
                write_to_screen_and_script_log "Plugin file $base_file conflicts with existing files"
                print_version_and_exit 1
            fi
        fi
    done
}

function check_single_plugin_file {
    debug ${FUNCNAME[0]}
    if [[ -f $3/$1 ]]
    then
        write_to_screen_and_script_log "Plugin file $1 conflicts with existing files"
        print_version_and_exit 1
    fi
    if [[ ! -f $2/$1 ]]
    then
        write_to_screen_and_script_log "Plugin file $1 is missing"
        print_version_and_exit 1
    fi

}

function setup_plugin {
    debug ${FUNCNAME[0]}
    write_to_script_log "Writing $1/uninstall_files"
    mkdir -p $1
    touch $1/uninstall_files
    uninstall_file=$1/uninstall_files
}

function copy_plugin_files {
    debug ${FUNCNAME[0]}
    for file in $1/*
    do
        if [[ -d $file ]]
        then
            copy_plugin_files $file $2 $3
        elif [[ -f $file ]]
        then
            local base_file=${file#$2/}
            write_to_script_log "Copying $file -> $3/$base_file"
            local dir=`dirname $3/$base_file`
            mkdir -p $dir
            cp $file $3/$base_file
            echo "UNINSTALL_FILES+=($3/$base_file)" >> $uninstall_file
        fi
    done
}

function copy_single_plugin_file {
    debug ${FUNCNAME[0]}
    write_to_script_log "Copying $2/$1 -> $3/$1"
    mkdir -p $3
    cp $2/$1 $3/$1
    echo "UNINSTALL_FILES+=($3/$1)" >> $uninstall_file
}

function delete_plugin_files {
    debug ${FUNCNAME[0]}
    if [[ ! -f $PLUGIN_DIR/$1/uninstall_files ]]
    then
        echo "Plugin $1 uninstall_files missing"
        print_version_and_exit 1
    fi
    UNINSTALL_FILES=()
    source $PLUGIN_DIR/$1/uninstall_files

    for file in ${UNINSTALL_FILES[@]}
    do
        delete_single_plugin_file $file
    done
}

function delete_single_plugin_file {
    debug ${FUNCNAME[0]}
    write_to_script_log "Deleting $1"
    if [[ -f $1 ]]
    then
        rm -f $1
        local dir=`dirname $1`
        set +e
        rmdir $dir 2> /dev/null
        set -e
    else
        write_to_script_log "Not found: $1"
    fi
}

function install_plugin {
    debug ${FUNCNAME[0]}
    if [[ $1 == *.tar.gz ]]
    then
        untar_plugin $1
        install_plugin_dir $PLUGIN_INSTALL_DIR
        write_to_screen_and_script_log "Cleaning up: $PLUGIN_INSTALL_DIR"
        rm -rf install_plugin/
    else
        install_plugin_dir $1
    fi
}

function untar_plugin {
    debug ${FUNCNAME[0]}
    if [[ ! -f $1 ]]
    then
        echo "Plugin tarball $1 was not found"
        print_version_and_exit 1
    fi
    write_to_screen_and_script_log "Unzipping: $1"
    mkdir install_plugin/
    tar xfz $1 -C install_plugin/
    for dir in install_plugin/*
    do
        if [[ -d $dir ]]
        then
            PLUGIN_INSTALL_DIR=$dir
        fi
    done
}

function install_plugin_dir {
    debug ${FUNCNAME[0]}
    if [[ ! -d $1 ]]
    then
        echo "Plugin dir $1 was not found"
        print_version_and_exit 1
    fi
    write_to_screen_and_script_log ">>> Installing plugin: $1"
    if [[ $RUN_MODE == "INSIDE" ]]; then
        /source/nuage-metroae/src/validate_plugin.py $1
    else
        src/validate_plugin.py $1
    fi
    get_plugin_name $1
    write_to_screen_and_script_log "Plugin name: $plugin_name"
    check_plugin_version $1
    write_to_screen_and_script_log "Checking files..."
    check_single_plugin_file plugin-cfg.yml $1 $PLUGIN_DIR/$plugin_name
    check_single_plugin_file menu $1 $PLUGIN_DIR/$plugin_name
    check_plugin_files $1/playbooks $1/playbooks $PLAYBOOK_WITH_BUILD_DIR
    check_plugin_files $1/roles $1/roles $ROLES_DIR
    check_plugin_files $1/schemas $1/schemas $SCHEMA_DIR
    write_to_screen_and_script_log "Installing plugin files..."
    setup_plugin $PLUGIN_DIR/$plugin_name
    copy_single_plugin_file plugin-cfg.yml $1 $PLUGIN_DIR/$plugin_name
    copy_single_plugin_file menu $1 $PLUGIN_DIR/$plugin_name
    copy_plugin_files $1/playbooks $1/playbooks $PLAYBOOK_WITH_BUILD_DIR
    copy_plugin_files $1/roles $1/roles $ROLES_DIR
    copy_plugin_files $1/schemas $1/schemas $SCHEMA_DIR
    write_to_screen_and_script_log "Plugin installation complete"
}

function uninstall_plugin {
    debug ${FUNCNAME[0]}
    if [[ ! -d $PLUGIN_DIR/$1 ]]
    then
        echo "Plugin $1 was not found"
        print_version_and_exit 1
    fi
    write_to_screen_and_script_log ">>> Uninstalling plugin: $1"
    write_to_screen_and_script_log "Removing plugin files..."

    delete_plugin_files $1
    delete_single_plugin_file $PLUGIN_DIR/$1/uninstall_files
    if [[ $RUN_MODE == "INSIDE" ]] && [[ -n $1 ]]; then
        rm -rf /metroae_data/metro_plugins/$1
    fi
    write_to_screen_and_script_log "Plugin removal complete"
}

function validate_plugin {
    debug ${FUNCNAME[0]}
    if [[ $1 == *.tar.gz ]]
    then
        untar_plugin $1
        validate_plugin_dir $PLUGIN_INSTALL_DIR
        write_to_screen_and_script_log "Cleaning up: $PLUGIN_INSTALL_DIR"
        rm -rf install_plugin/
    else
        validate_plugin_dir $1
    fi
}

function validate_plugin_dir {
    debug ${FUNCNAME[0]}
    if [[ ! -d $1 ]]
    then
        echo "Plugin dir $1 was not found"
        print_version_and_exit 1
    fi
    write_to_screen_and_script_log ">>> Validating plugin: $1"
    src/validate_plugin.py $1
}

function plugin_main {
    debug ${FUNCNAME[0]}
    if [[ $RUN_MODE == "CONTAINER" ]]; then
        debug "${FUNCNAME[0]}: RUN_MODE=$RUN_MODE"
        local action=$1
        if [[ ! -z $1 ]]
        then
            debug "${FUNCNAME[0]} args = $@"
            shift
            debug "${FUNCNAME[0]} args = $@"
            PLUGIN_INSTALL_ARGS=("$@")
            debug "${FUNCNAME[0]} PLUGIN_INSTALL_ARGS = $PLUGIN_INSTALL_ARGS"
            if [[ $action == "install" ]] || [[ $action == "validate" ]]; then
                copy_plugin_file_into_mount_point_if_necessary
            fi
            debug "${FUNCNAME[0]} action = $action"
            debug "${FUNCNAME[0]} PLUGIN_INSTALL_ARGS = $PLUGIN_INSTALL_ARGS"
            docker_metro_ae_exec plugin $action "${PLUGIN_INSTALL_ARGS[@]}"
            exit 0
        fi
    fi

    POSITIONAL=()
    case $1 in
        install)
        install_plugin "$2"
        print_version_and_exit 0
        ;;
        uninstall)
        uninstall_plugin "$2"
        print_version_and_exit 0
        ;;
        validate)
        validate_plugin "$2"
        print_version_and_exit 0
        ;;
        *)
        plugin_help ",plugin"
        print_version_and_exit 1
        ;;
    esac
}

#################################################################################
#                                    Tools                                      #
#################################################################################

function tools_main {
    debug ${FUNCNAME[0]}
    POSITIONAL=()
    local command_to_run=""
    case ${MATCH_MENU[3]} in
        unzip-files)
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            docker_exec env $CONTAINER_HOME/nuage-metroae/nuage-unzip.sh ${EXTRA_ARGS[@]}
        else
            ./nuage-unzip.sh ${EXTRA_ARGS[@]}
        fi
        print_version_and_exit 0
        ;;
        get_debug)
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            docker_exec env /usr/bin/python $CONTAINER_HOME/nuage-metroae/get_debug.py ${EXTRA_ARGS[@]}
        else
            /usr/bin/python get_debug.py ${EXTRA_ARGS[@]}
        fi
        print_version_and_exit 0
        ;;
        convert_csv_to_deployment)
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            docker_exec env workdir $CONTAINER_HOME/nuage-metroae /usr/bin/python convert_csv_to_deployment.py ${EXTRA_ARGS[@]}
        else
            /usr/bin/python convert_csv_to_deployment.py ${EXTRA_ARGS[@]}
        fi
        print_version_and_exit 0
        ;;
        convert_excel_to_deployment)
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            docker_exec env workdir $CONTAINER_HOME/nuage-metroae /usr/bin/python convert_excel_to_deployment.py ${EXTRA_ARGS[@]}
        else
            /usr/bin/python convert_excel_to_deployment.py ${EXTRA_ARGS[@]}
        fi
        print_version_and_exit 0
        ;;
        generate-example-from-schema)
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            docker_exec env /usr/bin/python $CONTAINER_HOME/nuage-metroae/generate_example_from_schema.py ${EXTRA_ARGS[@]}
        else
            /usr/bin/python generate_example_from_schema.py ${EXTRA_ARGS[@]}
        fi
        print_version_and_exit 0
        ;;
        encrypt-credentials)
        if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
            docker_exec env /usr/bin/python $CONTAINER_HOME/nuage-metroae/encrypt_credentials.py ${EXTRA_ARGS[@]}
        else
            /usr/bin/python encrypt_credentials.py ${EXTRA_ARGS[@]}
        fi
        print_version_and_exit 0
        ;;
        download)
        download_container ${EXTRA_ARGS[@]}
        print_version_and_exit 0
        ;;
        download-templates)
        download_container_templates ${EXTRA_ARGS[@]}
        print_version_and_exit 0
        ;;
        *)
        tools_help ",tools"
        print_version_and_exit 1
        ;;
    esac
}

#################################################################################
#                                     Help                                      #
#################################################################################

function main_help {
    debug ${FUNCNAME[0]}
    help_header
    echo "MetroAE usage:"
    echo ""
    print_menu_help "metroae%-50s %-1s\n" $1
    echo ""
    if [[ ! $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
        echo "[deployment] is the name of a deployment containing the required"
        echo "configuration files. The deployments are stored as directories under:"
        echo $DEPLOYMENTS_BASE_DIR
        echo ""
    fi
    echo "[options] include:"
    echo "  -h, --help:            Displays this help."
    if [[ ! $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
        echo "  --ansible-help:        Displays help for ansible arguments."
        echo "  -v, -vv, -vvv, -vvvv:  Runs with increasing levels of verbosity."
        echo "  --list:                Shows a list of all supported workflows"
        echo "  --skip-password:       Do not ask for a password.  Password can be"
        echo "                         provided via the environment variable"
        echo "                         METROAE_PASSWORD"
        echo "  --skip-build:          Runs workflow without performing build."
        echo "                         This will prevent changes in the deployment"
        echo "                         from taking effect, but it will be faster."
        echo "  --set-group <group>:   Sets the ownership of inventory and logs to"
        echo "                         the specified group so that other users in"
        echo "                         the group can access these files."
        echo ""
        echo "Any additional [options] are passed to the internal Ansible engine"
        echo "for processing"
    fi
    echo ""
    echo "Additional menu help is available by adding 'help' to the command line,"
    echo "e.g. 'metroae container help'"
    if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
        get_running_container_id
        get_container_id
        if [[ -z $RUNNING_CONTAINER_ID ]] && [[ -z $CONTAINER_ID ]]; then
            echo ""
            echo "It looks like you are trying to run the MetroAE container because"
            echo "this command was executed from a directory other than a local"
            echo "copy of the MetroAE repo. The MetroAE container was not found. To"
            echo "configure the MetroAE continer, please run 'metroae container setup'."
            echo "To run from a local copy of the MetroAE repo, change directory to"
            echo "the root of that local copy and try again. If you need to create"
            echo "a local copy of the MetroAE repo, check"
            echo "https://github.com/nuagenetworks/nuage-metroae for details."
        fi
    fi
}

function container_help {
    debug ${FUNCNAME[0]}
    help_header
    echo "MetroAE container usage:"
    echo ""
    print_menu_help "metroae%-50s %-1s\n" $1
    echo ""
}

function config_help {
    debug ${FUNCNAME[0]}
    if [[ $RUN_MODE == $REPO_RUN_MODE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE config. The metroae command"
        echo "appears to have been executed from a cloned workspace of the nuage-metroae github"
        echo "repo. MetroAE config is only operated from the MetroAE container. Please change"
        echo "your working directory and try again."
        echo ""
    elif [[ -z $METROAE_SETUP_TYPE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE config using the container."
        echo "The MetroAE container setup type (config, deploy, or both) does not appear to be"
        echo "configured. Please run 'metroae container setup' and try again."
        echo ""
    elif [[ $METROAE_SETUP_TYPE == $DEPLOY_SETUP_TYPE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE config using the container."
        echo "The MetroAE container appears to have been setup for DEPLOY only. Please change"
        echo "your setup type using 'metroae container setup' and try again."
        echo ""
    else
        help_header
        echo "MetroAE config is a tool that you can use to apply and manage day-zero configurations"
        echo "for Nuage Networks VSD. MetroAE config is only available via the MetroAE container."
        echo "You can execute 'metroae config', 'metroae config -h' or 'metroae config --help' to"
        echo "print this help and usage message."
        echo ""
        echo "The output, below, contains a list of 'positional arguments' that are supported by"
        echo "metroae config. You can execute 'metroae config <positional argument> -h' for help"
        echo "with each positional argument, e.g. 'metroae config create -h'."
        echo ""
        echo "MetroAE config usage:"
        echo ""
        print_menu_help "metroae%-50s %-1s\n" $1
        echo ""

        get_running_container_id
        if [[ -z $RUNNING_CONTAINER_ID ]]; then
            echo ""
            echo "The MetroAE container is not running. Full help text can only be accessed"
            echo "when the container is running. Please execute 'metroae container start'"
            echo "and try again."
        elif [[ $NUM_CLI_ARGS == 1 ]]; then
            docker_exec_config -h
        else
            # Remove the string "config"
            docker_exec_config "${CLI_ARGS[@]:1}"
        fi
    fi
}

function tools_help {
    debug ${FUNCNAME[0]}
    if [[ ($RUN_MODE == $CONTAINER_RUN_MODE && $METROAE_SETUP_TYPE != $CONFIG_SETUP_TYPE) || $RUN_MODE == $REPO_RUN_MODE  ]]; then
        help_header
        echo "MetroAE tools usage:"
        echo ""
        print_menu_help "metroae%-50s %-1s\n" $1
        echo ""
    elif [[ -z $METROAE_SETUP_TYPE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE tools using the container."
        echo "The MetroAE container setup type (config, deploy, or both) does not appear to be"
        echo "configured. Please run 'metroae container setup' and try again."
        echo ""
    elif [[ $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE tools using the container."
        echo "The MetroAE container appears to have been setup for CONFIG only. Please change"
        echo "your setup type using 'metroae container setup' and try again."
        echo ""
    fi
}

function plugin_help {
    debug ${FUNCNAME[0]}
    if [[ ($RUN_MODE == $CONTAINER_RUN_MODE && $METROAE_SETUP_TYPE != $CONFIG_SETUP_TYPE) || $RUN_MODE == $REPO_RUN_MODE  ]]; then
        help_header
        echo "MetroAE plugin usage:"
        echo ""
        print_menu_help "metroae%-50s %-1s\n" $1
        echo ""
    elif [[ -z $METROAE_SETUP_TYPE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE plugins using the container."
        echo "The MetroAE container setup type (config, deploy, or both) does not appear to be"
        echo "configured. Please run 'metroae container setup' and try again."
        echo ""
    elif [[ $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
        echo ""
        echo "It looks like you are trying to get help for MetroAE plugins using the container."
        echo "The MetroAE container appears to have been setup for CONFIG only. Please change"
        echo "your setup type using 'metroae container setup' and try again."
        echo ""
    fi
}

function help_header {
    debug ${FUNCNAME[0]}
    
    echo ""
    echo "Nuage Networks Metro Automation Engine (MetroAE) Version:" $METROAE_VERSION
    echo "Run mode is" $RUN_MODE
    if [[ ! -z  $METROAE_SETUP_TYPE ]]; then
        if [[ $METROAE_SETUP_TYPE == $CONFIG_SETUP_TYPE ]]; then
            current_setup_type="Config"
        elif [[ $METROAE_SETUP_TYPE == $DEPLOY_SETUP_TYPE ]]; then
            current_setup_type="Deploy"
        else
            current_setup_type="Both Config and Deploy"
        fi
        echo "Setup type is" $current_setup_type  
        if [[ $current_setup_type == "Both Config and Deploy" || $current_setup_type == "Config" ]]; then
            metroae_config_engine_version=`docker_exec_config version`
            echo "Nuage Networks" $metroae_config_engine_version
        fi
    fi
    echo ""
}

#################################################################################
#                                     Menu                                      #
#################################################################################

function switch_help {
    debug ${FUNCNAME[0]}
    case $1 in
        ,config*)
        config_help "$1"
        exit 0
        ;;
        ,container*)
        container_help "$1"
        exit 0
        ;;
        ,tools*)
        tools_help "$1"
        exit 0
        ;;
        ,plugin*)
        plugin_help "$1"
        exit 0
        ;;
        *)
        main_help "$1"
        exit 0
        ;;
    esac
}

function get_sub_menu {
    debug ${FUNCNAME[0]}
    SUB_MENU=""
    for (( i=0; i<=${#MENU[@]}; i+=$MENU_STRIDE )); do
        if [[ ${MENU[@]:$i:1} == $1 ]]; then
            SUB_MENU=("${MENU[@]:$i:$MENU_STRIDE}")
            debug "${FUNCNAME[0]}: SUB_MENU = $SUB_MENU"
        fi
    done
}

function print_menu_help {
    debug ${FUNCNAME[0]}
    for (( i=0; i<=${#MENU[@]} - 1; i+=$MENU_STRIDE )); do
        local menu_key=${MENU[@]:$i:1}
        local text_key=${MENU[@]:$i+1:1}
        local menu_family_key=${MENU[@]:$i+2:1}
        local operation_key=${MENU[@]:$i+3:1}
        local help_key=${MENU[@]:$i+4:1}
        if [[ "${menu_key}" == "$2"* ]] ;then
            if [[ $menu_family_key == "playbook" ]]; then
                printf "${1}" "${menu_key//,/ } [deployment] [options]" "${MENU[@]:($i + 1):1}"
            else
                printf "${1}" "${menu_key//,/ }" "${MENU[@]:($i + 1):1}"
            fi
        fi
    done
}

function parse_menu_args {
    debug ${FUNCNAME[0]}
    MENU_KEY=""
    MATCH_MENU=""
    EXTRA_ARGS=()
    debug "${FUNCNAME[0]}: Num args = $#"
    while [[ $# -gt 0 ]]; do
        debug "${FUNCNAME[0]}: Current arg = $1"
        if [[ $1 == "help" ]] || [[ $1 == "?" ]] || [[ $1 == "-h" ]] || [[ $1 == "--h" ]] || [[ $1 == "-help" ]] || [[ $1 == "--help" ]]; then
            MATCH_MENU=(",help" "help" "help" "")
            switch_help $MENU_KEY
            exit 0
        else
            MENU_KEY=$MENU_KEY","$1
            get_sub_menu $MENU_KEY
            if [[ -z $SUB_MENU ]]; then
                EXTRA_ARGS+=("$1")
            else
                # if we match with different menu, we just clear the extra args
                if [[ "${MATCH_MENU[@]}" != "('${SUB_MENU[@]}')" ]]; then
                    EXTRA_ARGS=()
                fi
                MATCH_MENU=("${SUB_MENU[@]}")
            fi
        fi
        shift
    done
}

#################################################################################
#                                     Main                                      #
#################################################################################

check_run_mode

source_container_config

source_UUID

source_menu

if [[ $# == 0 ]]; then
    main_help
    exit 0
fi

CLI_ARGS=("$@")
NUM_CLI_ARGS=$#

debug "main: Menu args = $@"

parse_menu_args "$@"

for menu_item in $MATCH_MENU
do
    debug "main: first menu_item = $menu_item"
done

# Do the file check and setup before running the commands
if [[ ${MATCH_MENU[0]} != ",container,setup" ]] && [[ ${MATCH_MENU[0]} != ",container,pull" ]] && [[ ${MATCH_MENU[0]} != ",container,destroy" ]] && [[ ${MATCH_MENU[0]} != ",container,status" ]] && [[ ${MATCH_MENU[0]} != ",container,update" ]] && [[ ${MATCH_MENU[0]} != ",container,download" ]] && [[ ${MATCH_MENU[0]} != ",container,download,image" ]] && [[ ${MATCH_MENU[0]} != ",container,download,templates" ]]; then
    check_for_prerequisite "$@"
fi

for menu_item in $MATCH_MENU
do
    debug "main: second menu_item = $menu_item"
done

debug "main: start case on MATCH_MENU"

debug "main: MATCH_MENU[2] = ${MATCH_MENU[2]}"

case ${MATCH_MENU[2]} in
    tools)
    debug "main: tools"
    tools_main
    print_version_and_exit 0
    ;;
    plugin)
    debug "main: plugin"
    plugin_main ${MATCH_MENU[3]} "${EXTRA_ARGS[@]}"
    print_version_and_exit 0
    ;;
    config)
    debug "main: config"
    if [[ ! $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
        echo ""
        write_to_screen_and_script_log "'config' command is not supported without the MetroAE container."
        echo "You can setup the container with 'metroae container setup'. Quitting."
        echo ""
        echo ""
        main_help
    elif [[ METROAE_SETUP_TYPE == $DEPLOY_SETUP_TYPE ]]; then
        echo ""
        write_to_screen_and_script_log "'config' command is not supported in a deploy-only setup."
        echo "Execute 'metroae container setup' to change your setup type."
        echo ""
        echo ""
        main_help
    else
        config_main ${MATCH_MENU[3]} "${EXTRA_ARGS[@]}"
    fi
    exit 0
    ;;
    playbook)
    debug "main: playbook"
    if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
        container_main ${MATCH_MENU[3]} "${EXTRA_ARGS[@]}"
    else
        deployment_main ${MATCH_MENU[3]} "${EXTRA_ARGS[@]}"
    fi
    print_version_and_exit 0
    ;;
    wizard)
    debug "main: wizard"
    if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
        docker_exec_interactive /usr/bin/python $CONTAINER_HOME/nuage-metroae/run_wizard.py "${EXTRA_ARGS[@]}"
    else
        ./run_wizard.py "${EXTRA_ARGS[@]}"
    fi
    print_version_and_exit 0
    ;;
    setup)
    debug "main: setup"
    if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
        echo "Setup cannot be run in MetroAE container"
        print_version_and_exit 1
    else
        ./setup.sh "${EXTRA_ARGS[@]}"
    fi
    print_version_and_exit 0
    ;;
    container)
    debug "main: container"
    container_main ${MATCH_MENU[3]} "${EXTRA_ARGS[@]}"
    print_version_and_exit 0
    ;;
    *)
    debug "main: other"
    if [[ $RUN_MODE == $CONTAINER_RUN_MODE ]]; then
        container_main "$@"
    else
        deployment_main "$@"
    fi
    print_version_and_exit 0
    ;;
esac
